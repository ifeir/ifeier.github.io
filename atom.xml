<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr·z</title>
  
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangqifei.top/"/>
  <updated>2018-04-22T09:24:20.026Z</updated>
  <id>http://blog.zhangqifei.top/</id>
  
  <author>
    <name>Mr·z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？</title>
    <link href="http://blog.zhangqifei.top/2018/02/07/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83%E3%80%81%E6%BB%9A%E5%8A%A8%E5%8F%91%E5%B8%83%E3%80%81%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB%EF%BC%9F%E5%85%B3%E9%94%AE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://blog.zhangqifei.top/2018/02/07/金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？/</id>
    <published>2018-02-07T11:42:22.000Z</published>
    <updated>2018-04-22T09:24:20.026Z</updated>
    
    <content type="html"><![CDATA[<p>根据 2017 年的 DevOps 发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。</p><p>作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不清楚这些术语背后的原理。本文试图总结当前主流的发布策略，每个的优劣，适用性，让开发人员特别是架构师对现代发布技术有一个更为清晰全面的认识，让大家能够根据自己的企业上下文，对发布策略做出正确的选型和实践。</p><h3 id="一、单服务器组发布"><a href="#一、单服务器组发布" class="headerlink" title="一、单服务器组发布"></a>一、单服务器组发布</h3><p>先解释下单服务器组的概念，早先我们机器资源比较紧张，不像现在云计算和虚拟化（包括容器技术）这么发达，所以应用机器基本是预先静态分配好的（一般由运维负责分配），原来应用 A 住在这 n 台机器上，那么下次升级发布的应用 A 也住在这 n 台机器上，所以称为单服务器组发布方式。</p><h4 id="蛮力发布"><a href="#蛮力发布" class="headerlink" title="蛮力发布"></a>蛮力发布</h4><p>如下图所示，这种发布方式比较简单粗暴，有点像我们传统的软件升级方式，主要靠手工完成，先将老版本 V1 全部下掉，再将新版本发到机器上去。这种方式会引入服务中断（停机），在开发测试环境是可行的，但对于生产环境发布，其会直接影响用户的使用体验，这种方式一般是不建议的。</p><center><br><img src="https://img-blog.csdn.net/20180413152557349" alt="这里写图片描述"><br></center><p><strong>优势：</strong></p><ul><li>简单成本低</li></ul><p><strong>不足：</strong></p><ul><li>服务中断用户受影响，出了问题回退也慢</li></ul><p><strong>适用场合：</strong></p><ul><li>开发测试环境</li><li>非关键应用（用户影响面小）</li><li>初创公司什么都缺，找夜深人静用户访问量小的时间干</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413151836748" alt="这里写图片描述"><br>蛮力发布会引入服务中断时间<br></center><h4 id="金丝雀发布（单服务器组）"><a href="#金丝雀发布（单服务器组）" class="headerlink" title="金丝雀发布（单服务器组）"></a>金丝雀发布（单服务器组）</h4><p>在蛮力发布基础上的一种简单改进发布方式，目前仍然是不少成长型技术组织的主流发布方式。单服务器组下的金丝雀发布的简化步骤如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413152452336" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>金丝雀发布一般先发 1 台，或者一个小比例，例如 2% 的服务器，主要做流量验证用，也称为金丝雀 (Canary) 测试（国内常称灰度测试）。以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。简单的金丝雀测试一般通过手工测试验证，复杂的金丝雀测试需要比较完善的监控基础设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回退的依据。</li><li>如果金丝测试通过，则把剩余的 V1 版本全部升级为 V2 版本。如果金丝雀测试失败，则直接回退金丝雀，发布失败。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小，金丝雀发布过程出现问题只影响少量用户</li></ul><p><strong>不足：</strong></p><ul><li>发布自动化程度不够，发布期间可引发服务中断</li></ul><p><strong>适用场合：</strong></p><ul><li>对新版本功能或性能缺乏足够信心</li><li>用户体验要求较高的网站业务场景</li><li>缺乏足够的自动化发布工具研发能力</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413152919230" alt="这里写图片描述"><br>少量金丝雀先接受流量，再全量发布<br></center><h4 id="滚动式发布（单服务器组）"><a href="#滚动式发布（单服务器组）" class="headerlink" title="滚动式发布（单服务器组）"></a>滚动式发布（单服务器组）</h4><p>在金丝雀发布基础上的进一步优化改进，是一种自动化程度较高的发布方式，用户体验比较平滑，是目前成熟型技术组织所采用的主流发布方式。单服务器组下的滚动发布的简化步骤如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413160543532" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>滚动式发布一般先发 1 台，或者一个小比例，如 2% 服务器，主要做流量验证用，类似金丝雀 (Canary) 测试。</li><li>滚动式发布需要比较复杂的发布工具和智能 LB，支持平滑的版本替换和流量拉入拉出。</li><li>每次发布时，先将老版本 V1 流量从 LB 上摘除，然后清除老版本，发新版本 V2，再将 LB 流量接入新版本。这样可以尽量保证用户体验不受影响。</li><li>一次滚动式发布一般由若干个发布批次组成，每批的数量一般是可以配置的（可以通过发布模板定义）。例如第一批 1 台（金丝雀），第二批 10%，第三批 50%，第四批 100%。每个批次之间留观察间隔，通过手工验证或监控反馈确保没有问题再发下一批次，所以总体上滚动式发布过程是比较缓慢的 (其中金丝雀的时间一般会比后续批次更长，比如金丝雀 10 分钟，后续间隔 2 分钟)。</li><li>回退是发布的逆过程，将新版本流量从 LB 上摘除，清除新版本，发老版本，再将 LB 流量接入老版本。和发布过程一样，回退过程一般也比较慢的。</li><li>滚动式发布国外术语通常叫 Rolling Update Deployment。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小，体验较平滑</li></ul><p><strong>不足：</strong></p><ul><li>发布和回退时间比较缓慢</li><li>发布工具比较复杂，LB 需要平滑的流量摘除和拉入能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>有一定的复杂发布工具研发能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413160829601" alt="这里写图片描述"><br>滚动式发布，流量平滑过渡，<br></center><h3 id="二、双服务器组发布"><a href="#二、双服务器组发布" class="headerlink" title="二、双服务器组发布"></a>二、双服务器组发布</h3><p>蓝绿发布仅适用于双服务器组发布，可以认为是对蛮力发布的一种简单优化发布方式。简化过程如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413161359955" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>V1 版本称为蓝组，V2 版本称为绿组，发布时通过 LB 一次性将流量从蓝组直接切换到绿组，不经过金丝雀和滚动发布，蓝绿发布由此得名；</li><li>出现问题回退也很直接，通过 LB 直接将流量切回蓝组。</li><li>发布初步成功后，蓝组机器一般不直接回收，而是留一个待观察期，视具体情况观察期的时间可长可短，观察期过后确认发布无问题，则可以回收蓝组机器。</li></ul><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响；</li><li>需要两倍机器资源；</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>机器资源有富余或者可以按需分配（AWS 云，或自建容器云）</li><li>暂不具备复杂滚动发布工具研发能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413161716274" alt="这里写图片描述"><br>蓝绿发布一次完成流程切换<br></center><h4 id="金丝雀发布（双服务器组）"><a href="#金丝雀发布（双服务器组）" class="headerlink" title="金丝雀发布（双服务器组）"></a>金丝雀发布（双服务器组）</h4><p>对蓝绿部署的一种简单优化，发布时先从绿组拉入 1 台金丝雀，待金丝雀验证通过再发全量。对比蓝绿发布，该发布方式的优势是有一个生产流量的金丝雀验证过程，可以减轻 V2 可能有问题的风险和影响面。简化发布过程如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413162041469" alt="这里写图片描述"><br></center><h4 id="滚动式发布（双服务器组）"><a href="#滚动式发布（双服务器组）" class="headerlink" title="滚动式发布（双服务器组）"></a>滚动式发布（双服务器组）</h4><p>滚动式发布是对上面的蓝绿和金丝雀发布的进一步优化，按批次增量滚动发布，提供更平滑的用户体验。</p><center><br><img src="https://img-blog.csdn.net/20180413162342844" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>发布前先申请一批新服务器，数量一般和 V1 版本相同，将 V2 版本应用发布到新服务器上。例如如果在 AWS 云上，则可以直接调用 API 申请一批新 VM，如果用容器云 Kubernetes，则可以直接启动一批新容器（使用 V2 版本容器镜像）。</li><li>一般会先通过 LB 拉入 1 台 V2 版本的机器，这台机器也相当于金丝雀，用于流量验证。</li><li>逐步按批次完成发布，每批只需要通过 LB 拉入 V2 版本，再拉出对应数量的 V1 版本。批次之间留有观察间隔，通过手工或监控反馈确保没有问题再继续发布。</li><li>发布有问题回退很快，直接通过 LB 将流量切回 V1 即可。</li><li>完成发布后，一般 V1 版本要保留观察以备万一，比如留 1 天，1 天后没有问题则回收 V1 机器资源。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>升级切换和回退（rollback）速度比单服务器组滚动发布要快，LB 切流量即可；</li></ul><p><strong>不足：</strong></p><ul><li>需要两倍机器资源；</li><li>发布工具比较复杂，LB 需要流量切换能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>机器资源有富余或者可以按需分配（AWS 云，或自建容器云）</li><li>有一定的发布工具研发能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413162608274" alt="这里写图片描述"><br>滚动式发布，流量平滑过渡<br></center><h3 id="三、其它发布方式"><a href="#三、其它发布方式" class="headerlink" title="三、其它发布方式"></a>三、其它发布方式</h3><p>上述都是偏传统的发布方式，能覆盖大部分应用发布场景。针对一些关键新功能的上线发布，或者一些特定的场景，还有一些特殊的发布方式。</p><h4 id="功能开关发布"><a href="#功能开关发布" class="headerlink" title="功能开关发布"></a>功能开关发布</h4><p>利用代码中的功能开关（Feature Flag/Toggle/Switch）来控制发布逻辑，一般不需要复杂的发布工具和智能 LB 配合，是一种相对比较低成本和简单的发布方式。这种方式也是支持现代 DevOps 理念，研发人员可以灵活定制和自助完成的发布方式。功能开关的原理如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413162726916" alt="这里写图片描述"><br>功能开关发布<br></center><p><strong>实践要点</strong></p><ul><li>功能开关发布需要一个配置中心或者开关中心这样的服务支持，例如携程的 Apollo 配置中心附录 6.3，或者开源的 FF4J附录 6.4，这些都支持开关发布，业界还有专门的功能开关 SaaS 服务，例如 LaunchDarkly附录 6.5。通过配置中心，运维或研发人员可以在运行期动态配置功能开关的值。当然，功能开关发布只是配置中心的一种使用场景，配置中心还能支持其它很多动态配置场景。</li><li>功能开关服务一般提供客户端 SDK，方便开发人员集成。在运行期，客户端 SDK 会同步最新的开关值，技术实现有推方式 (push)，也有拉方式 (pull)，或者推拉结合方式。</li><li>新功能（V2 new feature）和老功能（V1 old feature）住在同一套代码中，新功能隐藏在开关后面，如果开关没有打开，则走老代码逻辑，如果开关打开，则走新代码逻辑。技术实现上可以理解为一个简单的 if/else 逻辑。</li><li>应用上线后，开关先不打开，然后运维或研发人员通过开关中心打开新功能，经过流量验证新功能没有问题，则发布完成；如果有问题，则随时可以通过开关中心切回老功能逻辑。</li></ul><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li><li>相对于复杂的发布工具，实施比较简单，成本相对低廉</li><li>研发能够灵活定制发布逻辑，支持 DevOps 自助发布</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响；</li><li>对代码有侵入，代码逻辑会变复杂，需要定期清理老版本逻辑，维护成本变高</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>已有配置中心或开关中心服务</li><li>暂不具备研发复杂发布工具能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413162936972" alt="这里写图片描述"><br>通过功能开关一次完成流量切换<br></center><h4 id="A-B-测试"><a href="#A-B-测试" class="headerlink" title="A/B 测试"></a>A/B 测试</h4><p>A/B 测试附录 7.10原来主要用于产品功能的比对测试，收集用户反馈和对比数据做产品功能设计的决策。实际上，A/B 测试也可以作为一种新功能发布技术。下图展示基于 LB 实现的一种 A/B 测试发布。</p><center><br><img src="https://img-blog.csdn.net/20180413163047576" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>上图中，原来 PC 端和手机端都访问老版本 V1 服务（也称 A 组或控制组），当 V2 新版本（也称 B 组或实验组）发布以后，为了验证 V2 的功能正确性，同时也为了避免 V2 有问题时影响所有用户，先通过 LB 将手机端的流量切换到 V2 版本，经过一段时间的 A/B 比对测试和观察（主要通过用户和监控反馈），确保 V2 正常，则通过 LB 将全部流量切换到 V2。</li><li>基于 LB 方式实现 A/B 测试，LB 需要能够通过某种条件做流量路由，例如通过 client ip，设备类型，浏览器类型，甚至是定制的 HTTP Header 或查询字符串。</li><li>高级的 A/B 测试需要专门的平台支撑，wasabi附录 6.6就是 intuit 开源的一个支持高级 A/B 测试的平台，这类平台可以细粒度到针对某类用户做 A/B 测试，例如针对某个地区的用户，某个年龄段的用户，公司内部用户等等。举了例子，假设一个关键业务的新功能上线，为了降低风险采用 A/B 测试，可以做到先只让公司内部员工能访问到新功能，待新功能验证过，再全量放开给外部用户使用。</li><li>功能开关和 A/B 测试有点相似，但功能开关一般是无状态和全量的，无法做到针对某类特定用户进行测试，而 A/B 测试一般是有状态的，能够跟踪事务和用户级别的状态，可以实现针对某类特定用户进行测试。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>可以使用生产流量测试；</li><li>可以做到针对某类特定目标用户进行测试；</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度相对高，有一定技术门槛</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定的 A/B 测试平台研发能力</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/201804131632311" alt="这里写图片描述"><br>针对某类目标用户进行 A/B 测试<br></center><h4 id="影子测试"><a href="#影子测试" class="headerlink" title="影子测试"></a>影子测试</h4><p>对于一些涉及核心业务的遗留系统的升级改造，为了确保万无一失，有一种称为影子测试的大招，采用比较复杂的流量复制、回放和比对技术实现。下面是影子测试的一个样例架构图，</p><center><br><img src="https://img-blog.csdn.net/20180413163342859" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>目标实现老的 legacy 服务迁移升级到新的 experimental 服务。</li><li>测试开始前，需要在测试环境部署一份 legacy 服务和 experimental 服务，同时将生产数据库复制两份到测试环境。同时需要将生产请求日志收集起来，一般可以通过 kafka 队列收集，然后通过类似 goreplay附录 6.8这样的工具，消费 kafka 里头的请求日志，复制回放，将请求分发到 legacy 服务和 experimental 服务，收到响应后进行比对，如果所有响应比对成功，则可以认为 legacy 服务和 experimental 服务在功能逻辑上是等价的；如果有响应比对失败，则认为两者在功能逻辑上不等价，需要修复 experimental 并重新进行影子测试，直到全部比对成功。根据系统复杂度和关键性不同，比对测试时间短的可能需要几周，长的可达半年之久。</li><li>影子测试因为旁路在独立测试环境中进行，可以对生产流量完全无影响。</li><li>影子测试一般适用于遗留系统的等价重构迁移，例如.net 转 Java，或者 SQLServer 数据库升级为 MySQL 数据库，且外部依赖不能太多，否则需要开发很多 mock，测试部署成本会很高，且比对测试更加复杂和不稳定。</li><li>当当网有一个比较成功的交易系统.NET 转 Java 迁移项目附录 6.9，采用了影子测试技术，值得参考借鉴。</li></ul><p><strong>优势：</strong></p><ul><li>对生产用户体验完全无影响</li><li>可以使用生产真实流量进行测试（复制比对）</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度很高，技术门槛高，数据库的导出复制是难点</li><li>外部依赖不能太多，否则测试部署成本很高，且比对测试更加复杂和不稳定</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定影子测试平台研发能力，包括流量复制、数据库导出复制和分发比对系统。</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413163538922" alt="这里写图片描述"><br>影子测试对生产流量无影响<br></center><h3 id="四、比较"><a href="#四、比较" class="headerlink" title="四、比较"></a>四、比较</h3><p>下表对各种发布策略，从各个维度进行综合比较，供参考：</p><center><br><img src="https://img-blog.csdn.net/20180413163634468" alt="这里写图片描述"><br></center><h3 id="五、结论和建议"><a href="#五、结论和建议" class="headerlink" title="五、结论和建议"></a>五、结论和建议</h3><p>下面是对发布策略的一些选型建议，供不同阶段公司参考：</p><ul><li>蛮力发布一般是不建议采用的，除非是开发测试环境，用户体验不敏感的非关键应用，或者是创业期什么都缺时候的无奈之举。</li><li>如果暂时还不具备研发较复杂的滚动发布工具和配套智能 LB，则功能开关是一种不错的轻量级发布技术，投入相对较小的成本，可以让研发人员灵活定制发布逻辑。</li><li>金丝雀发布通过少量新版本服务器接收生产流量的方式去验证新版本，可以显著降低风险。金丝雀发布适用于大部分场景，一般成长型公司就可以采用。</li><li>对于达到一定业务体量的公司，考虑到用户体验对业务的关键性，则需要投入研发资源开发支持滚动式发布的工具和配套的智能 LB，实现自动化和零停机的发布。滚动式发布一般和金丝雀发布配合，先发一台金丝雀去验证流量，再按批次增量发布。</li><li>随着轻量级虚拟化（例如容器）的普及，双服务器组发布方式具有更快的发布和回退速度，是值得投入的高级发布技术。蓝绿部署仅适用于双服务器组，滚动式发布既可以在单服务器组上实现，也可以在双服务器组上实现。</li><li>对于涉及关键核心业务的新功能上线，采用 A/B 测试，可以显著降低发布风险，A/B 测试是唯一一种支持针对特定用户组进行生产测试的高级发布技术。当然 A/B 测试的投入不低，建议有一定研发能力的组织采用。</li><li>对于关键核心业务的迁移重构，为确保万无一失，最后的一个大招是影子测试，影子测试对生产流量和用户完全无影响。当然这个大招的投入成本和门槛都高，建议有足够业务体量和研发能力的组织投入。</li><li>上述的各种发布策略并不是非此即彼的，一个公司常常会综合采用多种发布技术作为互补，实现灵活的发布能力。例如主流的发布手段是金丝雀 + 滚动式发布，某些业务线可能根据业务场景需要采用功能开关发布，还有一些业务线则可能采用高级的 A/B 测试发布手段。</li></ul><h3 id="六、附录"><a href="#六、附录" class="headerlink" title="六、附录"></a>六、附录</h3><p><a href="https://github.com/ContainerSolutions/k8s-deployment-strategies" target="_blank" rel="noopener">https://github.com/ContainerSolutions/k8s-deployment-strategies</a></p><p><a href="https://opensource.com/article/18/2/feature-flags-ring-deployment-model" target="_blank" rel="noopener">https://opensource.com/article/18/2/feature-flags-ring-deployment-model</a></p><p><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo</a></p><p><a href="http://www.ff4j.org/" target="_blank" rel="noopener">http://www.ff4j.org/</a></p><p><a href="https://launchdarkly.com/" target="_blank" rel="noopener">https://launchdarkly.com/</a></p><p><a href="https://github.com/intuit/wasabi" target="_blank" rel="noopener">https://github.com/intuit/wasabi</a></p><p><a href="https://blog.zenika.com/2017/04/19/migration-dun-legacy-avec-goreplay/" target="_blank" rel="noopener">https://blog.zenika.com/2017/04/19/migration-dun-legacy-avec-goreplay/</a></p><p><a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">https://github.com/buger/goreplay</a></p><p><a href="http://blog.shurenyun.com/untitled-9/" target="_blank" rel="noopener">http://blog.shurenyun.com/untitled-9/</a></p><p><a href="https://en.wikipedia.org/wiki/A/B_testing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/A/B_testing</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据 2017 年的 DevOps 发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。&lt;/p&gt;
&lt;p&gt;作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="发布" scheme="http://blog.zhangqifei.top/tags/%E5%8F%91%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>ansible puppet saltstack三款自动化运维工具的对比！</title>
    <link href="http://blog.zhangqifei.top/2017/08/10/ansible%20puppet%20saltstack%E4%B8%89%E6%AC%BE%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>http://blog.zhangqifei.top/2017/08/10/ansible puppet saltstack三款自动化运维工具的对比/</id>
    <published>2017-08-10T06:41:22.000Z</published>
    <updated>2018-04-22T09:29:33.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础介绍"><a href="#一、基础介绍" class="headerlink" title="一、基础介绍"></a>一、基础介绍</h3><ul><li><a href="http://zhangqifei.top/2017/08/09/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7ansible/" target="_blank" rel="noopener">ansible基础介绍可参考</a></li><li><a href="http://zhangqifei.top/2017/08/07/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7puppet/" target="_blank" rel="noopener">puppet基础介绍可参考</a></li><li><a href="http://zhangqifei.top/2017/08/06/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7saltstack/" target="_blank" rel="noopener">saltstack基础介绍可参考</a></li></ul><h3 id="二、技术特性比较"><a href="#二、技术特性比较" class="headerlink" title="二、技术特性比较"></a>二、技术特性比较</h3><table><thead><tr><th>名称</th><th>Puppet</th><th>SaltStack</th><th>Ansible</th></tr></thead><tbody><tr><td>开发语言</td><td>Ruby</td><td>Python</td><td>Python</td></tr><tr><td>客户端</td><td>有</td><td>有</td><td>无</td></tr><tr><td>二次开发</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>通信验证</td><td>是</td><td>是</td><td>是</td></tr><tr><td>同学加密</td><td>标准SSL协议</td><td>AES加密</td><td>OpenSSH</td></tr><tr><td>平台支持</td><td>AIX,BSD,HP-UX,Linux,Mac OS X,Solaris,Windows</td><td>BSD,Linux,Mac OS X,Solaris,Windows</td><td>AIX,BSD,HP-UX,Linux,Mac OS X,Solaris</td></tr><tr><td>配置文件格式</td><td>Ruby语法格式</td><td>YAML</td><td>YAML</td></tr><tr><td>Web UI</td><td>提供</td><td>提供</td><td>提供（商业版本）</td></tr><tr><td>命令执行</td><td>不支持（配置模块可实现）</td><td>支持</td><td>支持</td></tr></tbody></table><h3 id="三、优缺点对比"><a href="#三、优缺点对比" class="headerlink" title="三、优缺点对比"></a>三、优缺点对比</h3><table><thead><tr><th>名称</th><th>优势</th><th>劣势</th><th>成本</th></tr></thead><tbody><tr><td>Puppet</td><td>模块由Ruby或Ruby子集编写<br>push命令可以即可触发变更<br>Web界面生成处理报表、资源清单、实时节点管理<br>代理运行端进行详细、深入的报告和对节点进行配置</td><td>相对其他工具较复杂，需学习Puppet的DSL或Ruby<br>安装过程缺少错误校验和产生错误报表</td><td>开源软件免费<br>SaltStack企业版每年内个节点花费约￥100</td></tr><tr><td>Saltstack</td><td>状态文件可用简单YAML配置模块或复杂的Python/PyDSL脚本<br>与客户端可以基于SSH或在被管节点安装代理<br>Web界面可看到运行的工作、minion状态、事件日志、可在客户端执行命令<br>扩展能力极强</td><td>Web界面像毒药竞争产品不稳定与相对不完善<br>缺乏生成深度报告的能力</td><td>开源软件免费<br>SaltStack企业版每年内个节点花费约￥150，随着数量增加相应的会有折扣</td></tr><tr><td>Ansible</td><td>模块可以用任何语言开发<br>备管节点不需要安装代理软件<br>有Web管理界面、可配置用户、组、资源清单和执行Playbook<br>安装、运行极其简单</td><td>对备管理节点为Windows有待加强<br>Web管理界面是内置的Ansible的一部分<br>需导入资源清单<br>执行效率较低</td><td>开源版本免费<br>Ansible Tower小于10台被管理节点免费<br>超过10太后没年每台需支付￥100~$250的支持服务费用</td></tr></tbody></table><h3 id="四、推荐场景"><a href="#四、推荐场景" class="headerlink" title="四、推荐场景"></a>四、推荐场景</h3><h4 id="4-1-Puppet"><a href="#4-1-Puppet" class="headerlink" title="4.1 Puppet"></a>4.1 Puppet</h4><p>　　Puppet也许是四款工具中最深入人心的。就可用操作、模块和用户界面而言，它是最全面的。Puppet呈现了数据中心协调的全貌，几乎涵盖每一个运行系统，为各大操作系统提供了深入的工具。初始设置比较简单，只需要在需要加以管理的每个系统上安装主服务器和客户端代理软件。</p><p>　　命令行接口(CLI)简单直观，允许通过puppet命令下载和安装模块。然后，需要对配置文件进行更改，好让模块适合所需的任务;应接到指令的客户端与主服务器联系时，会更改配置文件，或者客户端通过立即触发更改配置文件的推送(push)来进行更改。</p><p>　　还有一些模块可以提供和配置云服务器实例和虚拟服务器实例。所有模块和配置都使用基于Ruby的Puppet专属语言或者Ruby本身构建而成，因而除了系统管理技能外，还需要编程专业知识。</p><p>　　Puppet企业版拥有最全面的Web用户界面，允许使用主服务器上的预制模块和菜谱(cookbook)，实时控制被管理的节点。Web用户界面很适合用于管理，但是不允许对模块进行诸多配置。报告工具非常完善，提供了详细信息，以便了解代理软件运行如何、已做出什么样的变更。</p><h4 id="4-2-Ansible"><a href="#4-2-Ansible" class="headerlink" title="4.2 Ansible"></a>4.2 Ansible</h4><p>　　Ansible极其类似Salt，而不太类似Puppet或Chef。Ansible关注的重点是力求精简和快速，而且不需要在节点上安装代理软件。因此，Ansible通过SSH执行所有功能。Ansible基于Python;相比之下，Puppet和Chef基于Ruby。</p><p>　　Ansible可以通过Git软件库克隆，安装到Ansible主服务器上。安装完毕后，需要管理的节点被添加到Ansible配置环境，SSH授权密钥被附加到每个节点上，这与运行Ansible的用户有关。一旦完成了这步，Ansible主服务器可以通过SSH与节点进行通信，执行所有必要的任务。为了与默认情况下不允许根SSH访问的操作系统或发行版协同运行，Ansible接受sudo登录信息，以便在那些系统上以根用户的身份运行命令。</p><p>　　Ansible可以使用Paramiko(基于SSH2协议的Python实现)或标准SSH用于通信，不过还有一种加速模式，允许更快速、更大规模的通信。</p><p>　　针对确保服务在运行，或者触发更新和重新启动之类的简单任务，Ansible可以从命令行来运行，不需要使用配置文件。至于比较复杂的任务，Ansible配置通过名为Playbook的配置文件中的YAML语法来加以处理。Playbook还可以使用模板来扩展其功能。</p><p>　　Ansible有一大批模块，可用于管理各种系统以及亚马逊弹性计算云(EC2)和OpenStack等云计算基础设施。可以用几乎任何一种语言来编写自定义Ansible模块，只要模块输出是有效的JSON。</p><p>　　Ansible的Web用户界面以AnsibleWorks AWX的形式出现，但AWX与CLI并不直接联系在一起。这意味着，除非进行了同步过程，否则CLI里面的配置元素不会出现在Web用户界面中。你可以使用那个内置的同步工具，让两者保持一致，但需要按照预定计划运行同步工具。</p><h4 id="4-3-SaltStack"><a href="#4-3-SaltStack" class="headerlink" title="4.3 SaltStack"></a>4.3 SaltStack</h4><p>　　Salt类似Ansible，因为它也是基于CLI的工具，采用了推送方法实现客户端通信。它可以通过Git或通过程序包管理系统安装到主服务器和客户端上。客户端会向主服务器提出请求，请求在主服务器上得到接受后，就可以控制该客户端了。</p><p>　　Salt可以通过普通的SSH与客户端进行通信，但如果使用名为minion的客户端代理软件，可以大大增强可扩展性。此外，Salt含有一个异步文件服务器，可以为客户端加快文件服务速度，这完全是Salt注重高扩展性的一个体现。</p><p>　　与Ansible一样，你可以直接通过CLI，向客户端发出命令，比如启动服务或安装程序包;你也可以使用名为state的YAML配置文件，处理比较复杂的任务。还有“pillar”，这些是放在集中地方的数据集，YAML配置文件可以在运行期间访问它们。</p><p>　　你可以直接通过CLI，向客户端请求配置信息，比如内核版本或网络接口方面的详细信息。只要使用名为“grain”的库存元素，就可以描述客户端;这样一来，管理员可以轻松向某一种类型的服务器发出命令，不需要依赖已配置群组。比如说，只要使用一个CLI命令，你就可以向运行某个内核版本的每个客户端发送命令。</p><p>　　与Puppet、Chef和Ansible一样，Salt也提供了大量的模块，以处理特定的软件、操作系统和云服务。自定义模块可以用Python或PyDSL来编写。除了Unix管理外，Salt的确提供Windows管理功能，但它还是更擅长管理Unix和Linux系统。</p><p>　　Salt的Web用户界面Halite非常新，功能不如其他系统的Web用户界面来得全面。它提供了事件日志和客户端状态的视图，能够在客户端上运行命令，但除此之外乏善可陈。</p><p>　　Salt的较大优点在于可扩展性和弹性。你可以有多个级别的主服务器。上游主服务器可以控制下游主服务器及其客户端。另一个优点在于对等系统，让客户端可以向主服务器提出问题，然后主服务器从其他服务器得到答案，提供全面信息。如果需要在实时数据库中查询数据，以便完成客户端的配置，这个优点就很方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础介绍&quot;&gt;&lt;a href=&quot;#一、基础介绍&quot; class=&quot;headerlink&quot; title=&quot;一、基础介绍&quot;&gt;&lt;/a&gt;一、基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangqifei.top/2017/08/09/linux/
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="http://blog.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>运维自动化工具ansible</title>
    <link href="http://blog.zhangqifei.top/2017/08/09/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7ansible/"/>
    <id>http://blog.zhangqifei.top/2017/08/09/运维自动化工具ansible/</id>
    <published>2017-08-09T12:42:22.000Z</published>
    <updated>2018-04-22T09:29:32.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>ansible是一个基于python开发的轻量级自动化运维管理工具，可以用来批量执行命令，安装程序，支持playbook编排。它通过ssh协议来连接主机，去中心化，相对比puppet和saltstack无需安装客户即可实现文件传输、命令执行、应用部署、配置管理、任务编排等，显得更为简单与轻量。ansible只是提供一种框架，其基于模块工作的，本身没有批量部署。</p><h3 id="企业级自动化运维工具应用实战ansible"><a href="#企业级自动化运维工具应用实战ansible" class="headerlink" title="企业级自动化运维工具应用实战ansible"></a>企业级自动化运维工具应用实战ansible</h3><p>公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同学尽快实现，当你接到这个任务时，有没有更快的解决方案？</p><h3 id="Ansible发展史"><a href="#Ansible发展史" class="headerlink" title="Ansible发展史"></a>Ansible发展史</h3><p>Ansible</p><ul><li>创始人，Michael DeHaan（Cobbler 与Func 的作者）</li><li>2012-03-09，发布0.0.1版，红帽收购</li><li>2015-10-17，Red Hat宣布收购（据说是1.5 亿美元）</li></ul><p><strong>同类自动化工具GitHub关注程度（2016-07-10）</strong></p><table><thead><tr><th>同类的自动化运维工具</th><th>Watch（关注）</th><th>Star（点赞）</th><th>Fork（复制）</th><th>Contributors(贡献者)</th></tr></thead><tbody><tr><td>Ansible</td><td>1387</td><td>17716</td><td>5356</td><td>1428</td></tr><tr><td>Saltstack</td><td>530</td><td>6678</td><td>3002</td><td>1520</td></tr><tr><td>Puppet</td><td>463</td><td>4044</td><td>1678</td><td>425</td></tr><tr><td>Chef</td><td>383</td><td>4333</td><td>1806</td><td>464</td></tr><tr><td>Fabric</td><td>379</td><td>7334</td><td>1235</td><td>116</td></tr></tbody></table><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>模块化：调用特定的模块，完成特定任务</li><li>有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块</li><li>支持自定义模块</li><li>基于Python语言实现</li><li>部署简单，基于python和SSH(默认已安装)，agentless</li><li>安全，基于OpenSSH</li><li>支持playbook编排任务</li><li>幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况</li><li>无需代理不依赖PKI（无需ssl）</li><li>可使用任何编程语言写模块</li><li>YAML格式，编排任务，支持丰富的数据结构</li><li>较强大的多层解决方案</li></ul><h3 id="ansible架构"><a href="#ansible架构" class="headerlink" title="ansible架构"></a>ansible架构</h3><center><img src="http://zhangqifei.top/picture/ansible/4.png" alt="ansible架构"></center><h3 id="Ansible工作原理"><a href="#Ansible工作原理" class="headerlink" title="Ansible工作原理"></a>Ansible工作原理</h3><p><center><img src="http://zhangqifei.top/picture/ansible/5.png" alt="Ansible工作原理"></center></p><ul><li>ANSIBLE PLAYBOOKS：任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件</li><li>INVENTORY：Ansible管理主机的清单/etc/anaible/hosts</li><li>MODULES：Ansible执行命令的功能模块，多数为内置的核心模块，也可自定义</li><li>PLUGINS：模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用</li><li>API：供第三方程序调用的应用程序编程接口</li><li>ANSIBLE：组合INVENTORY、API、MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具</li></ul><p><strong>Ansible命令执行来源：</strong></p><ul><li>USER，普通用户，即SYSTEM ADMINISTRATOR</li><li>CMDB（配置管理数据库）API 调用</li><li>PUBLIC/PRIVATE CLOUD API调用</li><li>USER-&gt; Ansible Playbook -&gt; Ansibile</li></ul><p><strong>利用ansible实现管理的方式：</strong></p><ul><li>Ad-Hoc 即ansible命令，主要用于临时命令使用场景</li><li>Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前提的规划</li></ul><p><strong>Ansible-playbook（剧本）执行过程：</strong></p><ul><li>将已有编排好的任务集写入Ansible-Playbook</li><li>通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行</li></ul><p><strong>Ansible主要操作对象：</strong></p><ul><li>HOSTS主机</li><li>NETWORKING网络设备</li></ul><p><strong>注意事项</strong></p><ul><li>执行ansible的主机一般称为主控端，中控，master或堡垒机主控端Py:   thon版本需要2.6或以上</li><li>被控端Python版本小于2.4需要安装python-simplejson</li><li>被控端如开启SELinux需要安装libselinux-python</li><li>windows不能做为主控端</li></ul><h3 id="ansible安装-四种方式"><a href="#ansible安装-四种方式" class="headerlink" title="ansible安装(四种方式)"></a>ansible安装(四种方式)</h3><ul><li>rpm包安装: EPEL源<code>yum install ansible</code></li><li>编译安装:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum -y install python-jinja2 PyYAML python-paramiko </span><br><span class="line">python-babel python-crypto</span><br><span class="line">tar xf ansible-1.5.4.tar.gz</span><br><span class="line">cd ansible-1.5.4</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line">mkdir /etc/ansible</span><br><span class="line">cp -r examples/* /etc/ansible</span><br></pre></td></tr></table></figure><ul><li>Git方式安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/ansible/ansible.git --recursive</span><br><span class="line">cd ./ansible</span><br><span class="line">source ./hacking/env-setup</span><br></pre></td></tr></table></figure><ul><li>pip安装：pip是安装Python包的管理器，类似yum</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install python-pip python-devel</span><br><span class="line">yum install gcc glibc-devel zibl-devel rpm-bulid openssl-devel</span><br><span class="line">pip install  --upgrade pip</span><br><span class="line">pip install ansible--upgrade</span><br></pre></td></tr></table></figure><ul><li>确认安装：<code>ansible --version</code></li></ul><h3 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h3><p><strong>配置文件</strong><br><code>/etc/ansible/ansible.cfg</code> 主配置文件，配置ansible工作特性<br><code>/etc/ansible/hosts</code> 主机清单<br><code>/etc/ansible/roles/</code> 存放角色的目录</p><p><strong>程序</strong><br><code>/usr/bin/ansible</code> 主程序，临时命令执行工具<br><code>/usr/bin/ansible-doc</code> 查看配置文档，模块功能查看工具<br><code>/usr/bin/ansible-galaxy</code> 下载/上传优秀代码或Roles模块的官网平台<br><code>/usr/bin/ansible-playbook</code> 定制自动化任务，编排剧本工具<br><code>/usr/bin/ansible-pull</code> 远程执行命令的工具<br><code>/usr/bin/ansible-vault</code>  文件加密工具<br><code>/usr/bin/ansible-console</code>  基于Console界面与用户交互的执行工具</p><h4 id="主机清单inventory"><a href="#主机清单inventory" class="headerlink" title="主机清单inventory"></a>主机清单inventory</h4><ul><li>ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名</li><li>默认的inventory file为<code>/etc/ansible/hosts</code></li><li>inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成</li></ul><p><strong><code>/etc/ansible/hosts</code>文件格式</strong><br>inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">[root@centos7 ~]#vim /etc/ansible/hosts</span><br><span class="line">[web]</span><br><span class="line">192.168.109.100</span><br><span class="line">192.168.109.2</span><br><span class="line"></span><br><span class="line">[db]</span><br><span class="line">192.168.109.3</span><br><span class="line">192.168.109.100 //这里默认有个all</span><br><span class="line">[root@centos7 ~]#ansible db -m ping       </span><br><span class="line">192.168.109.100 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.168.109.3 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[websrvs]</span><br><span class="line">www[01:100].example.com</span><br><span class="line"></span><br><span class="line">[dbsrvs]</span><br><span class="line">db-[a:f].example.com</span><br></pre></td></tr></table></figure></p><h3 id="ansible-配置文件"><a href="#ansible-配置文件" class="headerlink" title="ansible 配置文件"></a>ansible 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ansible 配置文件/etc/ansible/ansible.cfg （一般保持默认）</span><br><span class="line">[defaults]</span><br><span class="line">#inventory      = /etc/ansible/hosts  # 主机列表配置文件</span><br><span class="line">#library        = /usr/share/my_modules/ # 库文件存放目录</span><br><span class="line">#remote_tmp     = $HOME/.ansible/tmp #临时py命令文件存放在远程主机目录</span><br><span class="line">#local_tmp      = $HOME/.ansible/tmp # 本机的临时命令执行目录</span><br><span class="line">#forks          = 5   # 默认并发数</span><br><span class="line">#sudo_user      = root  # 默认sudo 用户</span><br><span class="line">#ask_sudo_pass  = True  #每次执行ansible命令是否询问ssh密码</span><br><span class="line">#ask_pass       = True   </span><br><span class="line">#remote_port    = 22</span><br><span class="line">#host_key_checking = False  #检查对应服务器的host_key，建议取消注释第一次连接不用输入yes</span><br><span class="line">#log_path = /var/log/ansible.log 生成日志文件</span><br></pre></td></tr></table></figure><h3 id="ansible系列命令"><a href="#ansible系列命令" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ansible系列命令</span><br><span class="line">ansible    ansible-doc    ansible-playbook    ansible-vault ansible-console    ansible-galaxy    ansible-pull </span><br><span class="line"></span><br><span class="line">ansible-doc:显示模块帮助</span><br><span class="line">ansible-doc [options] [module...]</span><br><span class="line">-a              显示所有模块的文档</span><br><span class="line">-l, --list      列出可用模块</span><br><span class="line">-s, --snippet   显示指定模块的playbook片段</span><br><span class="line">示例：</span><br><span class="line">ansible-doc –l       列出所有模块</span><br><span class="line">ansible-doc ping     查看指定模块帮助用法</span><br><span class="line">ansible-doc –s  ping 查看指定模块帮助用法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点</span><br><span class="line"></span><br><span class="line">ansible &lt;host-pattern&gt; [-m module_name] [-a args] </span><br><span class="line">--version           显示版本</span><br><span class="line">-m module           指定模块，默认为command</span><br><span class="line">-v                  详细过程–vv-vvv更详细</span><br><span class="line">--list-hosts        显示主机列表，可简写—list</span><br><span class="line">-k, --ask-pass      提示连接密码，默认Key验证</span><br><span class="line">-K, --ask-become-pass  提示输入sudo</span><br><span class="line">-C, --check            检查，并不执行</span><br><span class="line">-T, --timeout=TIMEOUT  执行命令的超时时间，默认10s</span><br><span class="line">-u, --user=REMOTE_USER 执行远程执行的用户</span><br><span class="line">-b, --become           代替旧版的sudo切换</span><br><span class="line"></span><br><span class="line">ansible的Host-pattern</span><br><span class="line">    匹配主机的列表</span><br><span class="line">    All ：表示所有Inventory中的所有主机</span><br><span class="line">        ansible all –m ping </span><br><span class="line">    *  :通配符</span><br><span class="line">        ansible &quot;*&quot; -m ping </span><br><span class="line">        ansible 192.168.1.* -m ping</span><br><span class="line">        ansible &quot;*srvs&quot;  -m ping</span><br><span class="line">    或关系</span><br><span class="line">        ansible &quot;websrvs:appsrvs&quot;  -m ping</span><br><span class="line">        ansible &quot;192.168.1.10:192.168.1.20&quot; -m ping</span><br><span class="line">    逻辑与</span><br><span class="line">        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping</span><br><span class="line">        在websrvs组并且在dbsrvs组中的主机</span><br><span class="line">    逻辑非</span><br><span class="line">        ansible &apos;websrvs:!dbsrvs&apos; –m ping</span><br><span class="line">        在websrvs组，但不在dbsrvs组中的主机</span><br><span class="line">    综合逻辑</span><br><span class="line">        ansible &apos;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&apos; –m ping</span><br><span class="line">    正则表达式</span><br><span class="line">        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping</span><br><span class="line">        ansible &quot;~(web|db).*\.magedu\.com&quot; –m ping</span><br></pre></td></tr></table></figure><h3 id="ansible命令执行过程"><a href="#ansible命令执行过程" class="headerlink" title="ansible命令执行过程"></a>ansible命令执行过程</h3><p>ansible命令执行过程<code>ansible all -m command -a &#39;ls /root&#39;</code></p><ol><li>加载自己的配置文件默认<code>/etc/ansible/ansible.cfg</code></li><li>加载自己对应的模块文件，如command</li><li>通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户<code>$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件</code></li><li>给文件+x执行</li><li>执行并返回结果</li><li>删除临时py文件，sleep 0退出</li></ol><p>执行状态：<br>绿色：执行成功并且不需要做改变的操作<br>黄色：执行成功并且对目标主机做变更<br>红色：执行失败</p><h4 id="ansible使用示例"><a href="#ansible使用示例" class="headerlink" title="ansible使用示例"></a>ansible使用示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以wang用户执行ping存活检测</span><br><span class="line">ansible all -m ping -u wang -k</span><br><span class="line">以wang sudo至root执行ping存活检测</span><br><span class="line">ansible all -m ping -u wang –b -k</span><br><span class="line">以wangsudo至mage用户执行ping存活检测</span><br><span class="line">ansible all -m ping -u wang –b -k --become-user mage</span><br><span class="line">以wang sudo至root用户执行ls</span><br><span class="line">ansible all -m command -u wang--become-user=root -a &apos;ls/root&apos; -b –k -K</span><br></pre></td></tr></table></figure><h3 id="ansible常用模块"><a href="#ansible常用模块" class="headerlink" title="ansible常用模块"></a>ansible常用模块</h3><h4 id="Command：在远程主机执行命令，默认模块，可忽略-m选项"><a href="#Command：在远程主机执行命令，默认模块，可忽略-m选项" class="headerlink" title="Command：在远程主机执行命令，默认模块，可忽略-m选项"></a>Command：在远程主机执行命令，默认模块，可忽略-m选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令：</span><br><span class="line">chdir：    ＃运行该命令之前，切换到该目录。</span><br><span class="line">creates：  ＃一个文件当它已经存在时，这个步骤将不运行。</span><br><span class="line"></span><br><span class="line">ansible srvs -m command -a &apos;service vsftpd start&apos; </span><br><span class="line">ansible srvs -m command -a &apos;echo magedu |passwd --stdin wang&apos;   不成功此命令不支持$VARNAME &lt; &gt; | ;&amp; 等，用shell模块实现</span><br></pre></td></tr></table></figure><h4 id="Shell：和command相似，用shell执行命令"><a href="#Shell：和command相似，用shell执行命令" class="headerlink" title="Shell：和command相似，用shell执行命令"></a>Shell：和command相似，用shell执行命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m shell -a &apos;echo xxxxx |passwd –stdin wang&apos; </span><br><span class="line">调用bash执行命令类似cat /tmp/stanley.md | awk -F&apos;|&apos; &apos;&#123;print $1,$2&#125;&apos; &amp;&gt; /tmp/example.txt这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器</span><br><span class="line">[root@centos7 ~]#ansible all -m shell -a &apos;echo $HOSTNAME&apos;</span><br><span class="line">192.168.109.100 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">centos7.magedu.com</span><br><span class="line">192.168.109.2 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">centos7</span><br><span class="line">192.168.109.3 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">centos6.9</span><br></pre></td></tr></table></figure><h4 id="Script：运行脚本"><a href="#Script：运行脚本" class="headerlink" title="Script：运行脚本"></a>Script：运行脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f1.sh</span><br><span class="line">hostname</span><br><span class="line">date .... 定义了一些脚本等</span><br><span class="line"></span><br><span class="line">snsible websrvs -m script -a &apos;f1.sh&apos;</span><br></pre></td></tr></table></figure><h4 id="Copy-从服务器复制文件到客户端"><a href="#Copy-从服务器复制文件到客户端" class="headerlink" title="Copy:从服务器复制文件到客户端,"></a>Copy:从服务器复制文件到客户端,</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m copy -a &quot;src=/root/f1.sh dest=/tmp/f2.sh    owner=wang mode=600 backup=yes&quot; </span><br><span class="line">如目标存在，默认覆盖，此处指定先备份</span><br><span class="line"></span><br><span class="line">ansible srv -m copy -a &quot;content=&apos;test content\n&apos; dest=/tmp/f1.txt&quot; 利用内容，直接生成目标文件</span><br></pre></td></tr></table></figure><h4 id="cron：计划任务"><a href="#cron：计划任务" class="headerlink" title="cron：计划任务"></a>cron：计划任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">支持时间：minute，hour，day，month，weekday</span><br><span class="line">ansible srv -m cron -a &quot;minute=*/5 job=&apos;/usr/bin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&apos; name=Synctime&quot; 创建任务</span><br><span class="line">ansible srv -a &apos;crontab -l&apos; 查看任务</span><br><span class="line">ansible srv -m cron -a &apos;state=absent name=Synctime&apos;  删除任务</span><br><span class="line">计划任务目录路径 /var/spool/cron/root</span><br><span class="line">ansible srv -m cron -a &apos;disabled=yes job=&quot;/usr/bin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&quot; name=Synctime&apos;</span><br><span class="line">disables=yes 前面加上注释 no的话取消注释</span><br></pre></td></tr></table></figure><h4 id="fetch-从客户端取文件至服务器端，copy相反，目录可先tar"><a href="#fetch-从客户端取文件至服务器端，copy相反，目录可先tar" class="headerlink" title="fetch:从客户端取文件至服务器端，copy相反，目录可先tar"></a>fetch:从客户端取文件至服务器端，copy相反，目录可先tar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m fetch -a &apos;src=/root/a.sh dest=/data/scripts&apos;</span><br></pre></td></tr></table></figure><h4 id="file：设置文件属性"><a href="#file：设置文件属性" class="headerlink" title="file：设置文件属性"></a>file：设置文件属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m file -a &quot;path=/root/a.sh state=touch owner=wang mode=755&quot; //创建空文件 并设置权限等</span><br><span class="line"></span><br><span class="line">ansible web -m file -a &apos;src=/app/testfile  dest=/app/testfile-link state=link&apos; //创建软连接</span><br></pre></td></tr></table></figure><h4 id="hostname：管理主机名"><a href="#hostname：管理主机名" class="headerlink" title="hostname：管理主机名"></a>hostname：管理主机名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible web -m hostname -a &quot;name=websrv&quot;</span><br></pre></td></tr></table></figure><h4 id="yum：管理包"><a href="#yum：管理包" class="headerlink" title="yum：管理包"></a>yum：管理包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m yum -a &apos;name=httpd state=latest&apos;  安装</span><br><span class="line">ansible srv -m yum -a &apos;name=httpd,tftp state=latest&apos;  安装多个</span><br><span class="line">ansible srv -m yum -a &apos;name=httpd state=latest update_cache=yes&apos;  </span><br><span class="line">update_cache=yes 相当于yum clean all</span><br><span class="line">ansible srv -m yum -a &apos;name=httpd state=absent&apos;  删除</span><br></pre></td></tr></table></figure><h4 id="service：管理服务"><a href="#service：管理服务" class="headerlink" title="service：管理服务"></a>service：管理服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m service -a &apos;name=httpd state=stopped enabled=yes&apos;关闭并且设置开机启动 不支持多个命令</span><br><span class="line">ansible srv -m service -a &apos;name=httpd state=started&apos;启动</span><br><span class="line">ansible srv –m service –a &apos;name=httpd state=reloaded&apos;</span><br><span class="line">ansible srv -m service -a &apos;name=httpd state=restarted&apos;重启</span><br></pre></td></tr></table></figure><h4 id="user：管理用户"><a href="#user：管理用户" class="headerlink" title="user：管理用户"></a>user：管理用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m user -a &apos;name=user1 comment=&quot;test user&quot; uid=2048 home=/app/user1 group=root&apos;创建普通用户</span><br><span class="line">ansible srv -m user -a &apos;name=sysuser1 system=yes home=/app/sysuser1 &apos;创建系统用户</span><br><span class="line">ansible srv -m user -a &apos;name=user1 state=absent remove=yes&apos; 删除用户及家目录等数据</span><br></pre></td></tr></table></figure><h4 id="Group：管理组"><a href="#Group：管理组" class="headerlink" title="Group：管理组"></a>Group：管理组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m group -a &quot;name=testgroup system=yes&quot;</span><br><span class="line">ansible srv -m group -a &quot;name=testgroup state=absent&quot;</span><br></pre></td></tr></table></figure><h3 id="ansible系列命令-1"><a href="#ansible系列命令-1" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><h4 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">连接https://galaxy.ansible.com 下载相应的roles</span><br><span class="line">中文 http://www.ansible.com.cn/index.html</span><br><span class="line"></span><br><span class="line">列出所有已安装的galaxy </span><br><span class="line">    ansible-galaxy list</span><br><span class="line">安装galaxy</span><br><span class="line">    ansible-galaxy install geerlingguy.redis</span><br><span class="line">删除galaxy</span><br><span class="line">    ansible-galaxy remove geerlingguy.redis</span><br></pre></td></tr></table></figure><h4 id="ansible-pull"><a href="#ansible-pull" class="headerlink" title="ansible-pull"></a>ansible-pull</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible-pull</span><br><span class="line">推送命令至远程，效率无限提升，对运维要求较高</span><br></pre></td></tr></table></figure><h4 id="Ansible-playbook"><a href="#Ansible-playbook" class="headerlink" title="Ansible-playbook"></a>Ansible-playbook</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook hello.yml</span><br><span class="line">例子：</span><br><span class="line">vim hello.yml</span><br><span class="line">- hosts: test</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">  - name: hello world </span><br><span class="line">    command: wall &quot;hello world&quot;</span><br></pre></td></tr></table></figure><h4 id="Ansible-vault"><a href="#Ansible-vault" class="headerlink" title="Ansible-vault"></a>Ansible-vault</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">功能：管理加密解密yml文件</span><br><span class="line">    ansible-vault [create|decrypt|edit|encrypt|rekey|view]</span><br><span class="line">    ansible-vault encrypt hello.yml 加密</span><br><span class="line">    ansible-vault decrypt hello.yml 解密</span><br><span class="line">    ansible-vault view hello.yml 查看</span><br><span class="line">    ansible-vault edit hello.yml 编辑加密文件</span><br><span class="line">    ansible-vault rekey hello.yml 修改口令</span><br><span class="line">    ansible-vault create new.yml 创建新文件</span><br></pre></td></tr></table></figure><h4 id="Ansible-console"><a href="#Ansible-console" class="headerlink" title="Ansible-console"></a>Ansible-console</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ansible-console：2.0+新增，可交互执行命令，支持tab</span><br><span class="line">    root@test(2)[f:10] $</span><br><span class="line">        执行用户@当前操作的主机组(当前组的主机数量)[f:并发数]$</span><br><span class="line">    设置并发数：forks n  例如：forks 10</span><br><span class="line">    切换组：cd 主机组例如：cd web</span><br><span class="line">    列出当前组主机列表：list</span><br><span class="line">    列出所有的内置命令：?或help</span><br><span class="line">示例：</span><br><span class="line">root@all (2)[f:5]$ list</span><br><span class="line">root@all (2)[f:5]$ cd appsrvs</span><br><span class="line">root@appsrvs (2)[f:5]$ list </span><br><span class="line">root@appsrvs(2)[f:5]$ yum name=httpd state=present</span><br><span class="line">root@appsrvs(2)[f:5]$ service name=httpd state=started</span><br></pre></td></tr></table></figure><h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><ul><li>playbook是由一个或多个“play”组成的列表</li><li>play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联同起来按事先编排的机制同唱一台大戏</li><li>Playbook采用YAML语言编写</li></ul><p><center><img src="http://zhangqifei.top/picture/ansible/6.png" alt="playbook"></center></p><h4 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h4><ul><li>YAML是一个可读性高的用来表达资料序列的格式。YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。Clark Evans在2001年在首次发表了这种语言，另外IngydötNet与Oren Ben-Kiki也是这语言的共同设计者</li><li>YAML Ain’tMarkup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</li><li>特性<ul><li>YAML的可读性好</li><li>YAML和脚本语言的交互性好</li><li>YAML使用实现语言的数据类型</li><li>YAML有一个一致的信息模型</li><li>YAML易于实现</li><li>YAML可以基于流来处理</li><li>YAML表达能力强，扩展性好</li></ul></li></ul><p>更多的内容及规范参见<a href="http://www.yaml.org" target="_blank" rel="noopener">http://www.yaml.org</a></p><h4 id="YAML语法简介"><a href="#YAML语法简介" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h4><ul><li>在单一档案中，可用连续三个连字号(——)区分多个档案。另外，还有选择性的连续三个点号( … )用来表示档案结尾</li><li>次行开始正常写Playbook的内容，一般建议写明该Playbook的功能</li><li>使用#号注释代码</li><li>缩进必须是统一的，不能空格和tab混用</li><li>缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的</li><li>YAML文件内容和Linux系统大小写判断方式保持一致，是区别大小写的，k/v的值均需大小写敏感</li><li>k/v的值可同行写也可换行写。同行使用:分隔</li><li>v可是个字符串，也可是另一个列表一个完整的代码块功能需最少元素需包括name: task</li><li>一个name只能包括一个task</li><li>YAML文件扩展名通常为yml或yaml</li></ul><h5 id="YAML语法简介-1"><a href="#YAML语法简介-1" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dictionary：字典，通常由多个key与value构成</span><br><span class="line">示例：</span><br><span class="line">---</span><br><span class="line"># An employee record</span><br><span class="line">name: Example Developer</span><br><span class="line">job: Developers</span><br><span class="line">kill: Elite</span><br><span class="line">也可以将key:value放置于&#123;&#125;中进行表示，用,分隔多个key:value</span><br><span class="line">示例：</span><br><span class="line">---</span><br><span class="line"># An employee record</span><br><span class="line">&#123;name: Example Developer, job: Developer, skill: Elite&#125;</span><br></pre></td></tr></table></figure><h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><p>YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用”-“来代表，Map里的键值对用”:”分隔<br>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name: John Smith</span><br><span class="line">age: 41</span><br><span class="line">gender: Male</span><br><span class="line">spouse:</span><br><span class="line">  name: Jane Smith</span><br><span class="line">  age: 37</span><br><span class="line">  gender: Female</span><br><span class="line">children:</span><br><span class="line">  - name: Jimmy Smith</span><br><span class="line">    age: 17</span><br><span class="line">    gender: Male</span><br><span class="line">  - name: Jenny Smith</span><br><span class="line">    age 13</span><br><span class="line">    gender: Female</span><br></pre></td></tr></table></figure></p><h3 id="Playbook核心元素"><a href="#Playbook核心元素" class="headerlink" title="Playbook核心元素"></a>Playbook核心元素</h3><ul><li>Hosts      执行的远程主机列表</li><li>Tasks      任务集</li><li>Varniables 内置变量或自定义变量在playbook中调用</li><li>Templates  模板，可替换模板文件中的变量并实现一些简单逻辑的文件</li><li>Handlers   和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行</li><li>tags       标签指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断<code>ansible-playbook –t tagsname useradd.yml</code><br>示例:安装httpd 并且开机启动<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim test1.yml</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: install package</span><br><span class="line">      yum: name=httpd start=present</span><br><span class="line">    - name: start service</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">      </span><br><span class="line">ansible-playbook test1.yml 执行</span><br></pre></td></tr></table></figure></li></ul><h5 id="playbook基础组件"><a href="#playbook基础组件" class="headerlink" title="playbook基础组件"></a>playbook基础组件</h5><ul><li>Hosts：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，须事先定义在主机清单中</span><br><span class="line">可以是如下形式：</span><br><span class="line">one.example.com</span><br><span class="line">one.example.com:two.example.com</span><br><span class="line">192.168.1.50</span><br><span class="line">192.168.1.*</span><br><span class="line"></span><br><span class="line">Websrvs:dbsrvs两个组的并集</span><br><span class="line">Websrvs:&amp;dbsrvs两个组的交集</span><br><span class="line">webservers:!phoenix  在websrvs组，但不在dbsrvs组</span><br><span class="line">示例:-hosts: websrvs：dbsrvs</span><br></pre></td></tr></table></figure><ul><li>remote_user: </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户</span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    -name: test connection</span><br><span class="line">    ping: </span><br><span class="line">    remote_user: magedu</span><br><span class="line">    sudo: yes       默认sudo为root</span><br><span class="line">    sudo_user:wang  sudo为wang</span><br></pre></td></tr></table></figure><ul><li>task列表和action</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">play的主体部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。在运行自下而下某playbook时，如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可</span><br><span class="line"></span><br><span class="line">task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致</span><br><span class="line"></span><br><span class="line">每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出</span><br></pre></td></tr></table></figure><ul><li>tasks：任务列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    (1) action: module arguments</span><br><span class="line">    (2) module: arguments 建议使用</span><br><span class="line">    注意：shell和command模块后面跟命令，而非key=value</span><br><span class="line">某任务的状态在运行后为changed时，可通过“notify&quot;通知给相应的handlers</span><br><span class="line">任务可以通过&quot;tags&quot;打标签，而后可在ansible-playbook命令上使用-t指定进行调用</span><br><span class="line">示例：</span><br><span class="line">tasks:</span><br><span class="line">  - name: disable selinux</span><br><span class="line">    command: /sbin/setenforce 0</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">如果命令或脚本的退出码不为零，可以使用如下方式替代</span><br><span class="line">tasks:</span><br><span class="line">  - name: run this command and ignore the result</span><br><span class="line">    shell: /usr/bin/somecommand|| /bin/true</span><br><span class="line"></span><br><span class="line">或者使用ignore_errors来忽略错误信息：</span><br><span class="line">tasks:</span><br><span class="line">  - name: run this command and ignore the result</span><br><span class="line">    shell: /usr/bin/somecommand</span><br><span class="line">    ignore_errors: True</span><br><span class="line">    </span><br><span class="line">运行playbook的方式</span><br><span class="line">    ansible-playbook &lt;filename.yml&gt; ... [options]</span><br><span class="line">常见选项</span><br><span class="line">    --check 只检测可能会发生的改变，但不真正执行操作</span><br><span class="line">    --list-hosts 列出运行任务的主机</span><br><span class="line">    --limit 主机列表只针对主机列表中的主机执行</span><br><span class="line">    -v 显示过程-vv-vvv更详细</span><br><span class="line">示例</span><br><span class="line">    ansible-playbook  file.yml --check 只检测</span><br><span class="line">    ansible-playbook  file.yml </span><br><span class="line">    ansible-playbook  file.yml --limit websrvs</span><br></pre></td></tr></table></figure><h4 id="Playbook-VS-ShellScripts"><a href="#Playbook-VS-ShellScripts" class="headerlink" title="Playbook VS ShellScripts"></a>Playbook VS ShellScripts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SHELL脚本</span><br><span class="line">#!/bin/bash</span><br><span class="line"># 安装Apache</span><br><span class="line">yum install --quiet -y httpd</span><br><span class="line"># 复制配置文件</span><br><span class="line">cp /path/to/config/httpd.conf /etc/httpd/conf/httpd.conf</span><br><span class="line">cp /path/to/httpd-vhosts.conf /etc/httpd/conf/httpd-vhosts.conf</span><br><span class="line"># 启动Apache，并设置开机启动</span><br><span class="line">service httpd start </span><br><span class="line">chkconfig httpd on</span><br><span class="line"></span><br><span class="line">Playbook定义</span><br><span class="line">---</span><br><span class="line">  - hosts: all</span><br><span class="line">    tasks: </span><br><span class="line">      - name: &quot;安装Apache&quot;</span><br><span class="line">        command: yum install -q -y httpd</span><br><span class="line">      - name: &quot;复制配置文件&quot;</span><br><span class="line">        command: cp /tmp/httpd.conf/ etc/httpd/conf/httpd.conf</span><br><span class="line">        command: cp /tmp/httpd-vhosts.conf/ etc/httpd/conf/httpd-vhosts.conf</span><br><span class="line">      - name: &quot;启动Apache，并设置开机启动&quot;</span><br><span class="line">        service: name=httpd state=started enabled=yes</span><br></pre></td></tr></table></figure><h5 id="示例system-yml："><a href="#示例system-yml：" class="headerlink" title="示例system.yml："></a>示例system.yml：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">  - hosts: allre</span><br><span class="line">    mote_user: root</span><br><span class="line">    </span><br><span class="line">    tasks:</span><br><span class="line">      - name: create mysql user</span><br><span class="line">        user: name=mysql system=yes uid=36</span><br><span class="line">      - name: create a group </span><br><span class="line">        group: name=httpd system=yes</span><br></pre></td></tr></table></figure><h4 id="Playbook示例"><a href="#Playbook示例" class="headerlink" title="Playbook示例"></a>Playbook示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例：httpd.yml</span><br><span class="line"></span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: Install httpd</span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: Install configure file</span><br><span class="line">      copy: src=files/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">    - name: start service</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br></pre></td></tr></table></figure><h4 id="handlers和notify结合使用触发条件"><a href="#handlers和notify结合使用触发条件" class="headerlink" title="handlers和notify结合使用触发条件"></a>handlers和notify结合使用触发条件</h4><ul><li>Handlers</li><li>是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作</li><li>notify这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作</li></ul><h4 id="Playbook中handlers使用"><a href="#Playbook中handlers使用" class="headerlink" title="Playbook中handlers使用"></a>Playbook中handlers使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- hosts:websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: Install httpd </span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: Install configure file</span><br><span class="line">      copy: src=files/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">      notify: restart httpd</span><br><span class="line">    - name: ensure apache is running</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">    </span><br><span class="line">    handlers:</span><br><span class="line">      - name: restart httpd</span><br><span class="line">        service: name=httpd status=restarted</span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: add group nginx</span><br><span class="line">      tags: user</span><br><span class="line">      user: name=nginx state=present</span><br><span class="line">    - name: add user nginx</span><br><span class="line">      user: name=nginx state=present group=nginx</span><br><span class="line">    - name: Install Nginx</span><br><span class="line">      yum: name=nginx state=present</span><br><span class="line">    - name: config </span><br><span class="line">      copy: src=/root/config.txt dest=/etc/nginx/nginx.conf</span><br><span class="line">      notify:</span><br><span class="line">        - Restart Nginx</span><br><span class="line">        - Check Nginx Process</span><br><span class="line">    </span><br><span class="line">    handlers:</span><br><span class="line">      - name: Restart Nginx</span><br><span class="line">        service: name=nginx state=restarted enabled=yes</span><br><span class="line">      - name: Check Nginx process</span><br><span class="line">        shell:  killall -0 nginx &gt; /tmp/nginx.log</span><br></pre></td></tr></table></figure></p><h4 id="Playbook中tags使用"><a href="#Playbook中tags使用" class="headerlink" title="Playbook中tags使用"></a>Playbook中tags使用</h4><p>示例：httpd.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: Install httpd</span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: Install configure file</span><br><span class="line">      copy: src=files/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">      tags: conf</span><br><span class="line">    - name: start httpd service</span><br><span class="line">      tags: service</span><br><span class="line">      service: name=httpd state=started enabled=yes </span><br><span class="line">      </span><br><span class="line">ansible-playbook –t conf httpd.yml</span><br><span class="line">    -t //--tags</span><br></pre></td></tr></table></figure></p><h6 id="综合实例：安装httpd-并且启动端口是8080"><a href="#综合实例：安装httpd-并且启动端口是8080" class="headerlink" title="综合实例：安装httpd 并且启动端口是8080"></a>综合实例：安装httpd 并且启动端口是8080</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">本机先安装httpd 把httpd配置文件 /etc/httpd/conf/httpd.conf 里面端口改为8080</span><br><span class="line"></span><br><span class="line">[root@centos7 app]#cat httpd.yml </span><br><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: install httpd</span><br><span class="line">      yum: name=httpd</span><br><span class="line">    - name: copy config file</span><br><span class="line">      copy: src=/app/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">    - name: start httpd</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">      </span><br><span class="line">[root@centos7 app]#ansible-playbook httpd.yml</span><br><span class="line">现在把端口改为80</span><br><span class="line">[root@centos7 app]#cat httpd.yml </span><br><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: install httpd</span><br><span class="line">      yum: name=httpd</span><br><span class="line">    - name: copy config file</span><br><span class="line">      copy: src=/app/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">      notify: restart httpd</span><br><span class="line">    - name: start httpd</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart httpd</span><br><span class="line">      service: name=httpd state=restarted</span><br><span class="line">[root@centos7 app]#ansible-playbook --limit 192.18.109.1  httpd.yml 只针对这一台机器</span><br><span class="line"></span><br><span class="line">[root@centos7 app]#ansible web -m shell -a &apos;ss -ntl|grep 80&apos;</span><br><span class="line">192.168.109.100 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">LISTEN     0      128         :::80                      :::*                 </span><br><span class="line">192.168.109.2 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">LISTEN     0      128         :::80                      :::*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;ansible是一个基于python开发的轻量级自动化运维管理工具，可以用来批量执行命令，安装程序，支持playbook编排
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="http://blog.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ansible" scheme="http://blog.zhangqifei.top/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>运维自动化工具puppet</title>
    <link href="http://blog.zhangqifei.top/2017/08/07/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7puppet/"/>
    <id>http://blog.zhangqifei.top/2017/08/07/运维自动化工具puppet/</id>
    <published>2017-08-07T11:42:22.000Z</published>
    <updated>2018-04-22T09:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="puppet的概念"><a href="#puppet的概念" class="headerlink" title="puppet的概念"></a>puppet的概念</h2><p>Puppet是一款使用GPLV2X协议授权的开源管理配置工具，用Ruby语言开发。其既可以通过客户端–服务器的方式运行，也可以独立运行。Puppet可以为系统管理员提供方便、快捷的系统自动化管理。对于系统管理员来说通过Puppet配置管理系统，底层的操作系统的发行版本是透明的，Puppet通过（Provider又称提供者）属性来完成软件的配置与安装，管理员不必关心操作系统的种类与发行版本，<br>Puppet还可以提供一个强大的框架来完成系统管理功能，在框架的基础上系统管理员可以通过Puppet语言来描述系统的一些事务，如安装软件、初始化系统、启动、删除服务、推送配置文件和差异化配置管理服务器等。同时系统管理员和系统管理员之间可以分享用Puppet语言描述好的事务，从而减少重复劳动，提高工作效率。</p><h3 id="puppet工作模型"><a href="#puppet工作模型" class="headerlink" title="puppet工作模型"></a>puppet工作模型</h3><ul><li>a.部署调度<ul><li>puppet master在一台服务器以守护进程方式运行，同时也包含客户端各节点的配置信息，puppet agent 在与master的通信过程中，通过标准的SSL协议进行加密和验证，验证通过后，agent从masteer上读取响应节点信息应用在本地。</li></ul></li><li>b.配置语言和资源抽象<ul><li>puppet使用描述性语言来定义配置项，在puppet中将配置项被称为resource，当Agent连接Master时，Master并不知道Agent的操作系统型号和版本。Agent通过Facter工具收集系统相关信息，并通过SSL协议将Agent的信息传递给Master。Master根据Agent收集到的相关信息，通过资源的提供者来为Agent服务。比如Package资源收到Agent的信息后，会识别Agent的系统型号版本，并通过资源提供者（如yum aptitude pkgadd apt-get等）匹配，为Agent服务。</li></ul></li><li>c.事物层<pre><code>Puppet事务层其实就是它的解析引擎。Puppet事务层配置每一台主机的过程包括：</code></pre><ul><li>解析和配置编译。</li><li>将编译好的配置同步到Agent。</li><li>在Agent上应用配置。</li><li>向Master报告运行结果。</li></ul></li></ul><p>首先Puppet会创建一个图表来表示所有资源的关系和上下游执行顺序，以及和Agent的关系。然后Puppet将按照资源之间的关系和上下游顺序依次执行。<br>接着Puppet为每一个Agent获取相应的资源，并把它们编译成“目录”，然后将目录依次分发到各主机，并通过Agent来应用它们，最后应用结果以报告形式反馈给Master。自动化运维工具puppet安装配置</p><h3 id="puppet的细节和原理"><a href="#puppet的细节和原理" class="headerlink" title="puppet的细节和原理"></a>puppet的细节和原理</h3><p><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221202568971.png" alt=""><br></center><br>Puppet采用了非常简单的C/S架构，所有数据的交互都通过SSL进行，以保证安全。</p><ol><li>客户端Puppetd向Master发起认证请求，或使用带签名的证书。</li><li>Master告诉Client你是合法的。</li><li>客户端Puppetd调用Facter，Facter探测出主机的一些变量，例如主机名、内存大小、IP地址等。Puppetd将这些信息通过SSL连接发送到服务器端。</li><li>服务器端的Puppet Master检测客户端的主机名，然后找到manifest对应的node配置，并对该部分内容进行解析。Facter送过来的信息可以作为变量处 理，node牵涉到的代码才解析，其他没牵涉的代码不解析。解析分为几个阶段，首先是语法检查，如果语法错误就报错；如果语法没错，就继续解析，解析的结 果生成一个中间的“伪代码”（catelog），然后把伪代码发给客户端。</li><li>客户端接收到“伪代码”，并且执行。</li><li>客户端在执行时判断有没有File文件，如果有，则向fileserver发起请求。</li><li>客户端判断有没有配置Report，如果已配置，则把执行结果发送给服务器。</li><li>服务器端把客户端的执行结果写入日志，并发送给报告系统。</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">两台机器：</span><br><span class="line">192.168.1.100（服务端）</span><br><span class="line">192.168.1.101 （客户端）</span><br><span class="line">两台机器关闭selinux，清空iptables规则，并保存，设置hostname</span><br><span class="line"></span><br><span class="line">100上</span><br><span class="line">hostname   master.aming.com</span><br><span class="line">编辑/etc/sysconfig/network  定义hostname</span><br><span class="line"></span><br><span class="line">101上</span><br><span class="line">hostname   client.aming.com</span><br><span class="line">编辑/etc/sysconfig/network  定义hostname</span><br><span class="line">重启服务器</span><br><span class="line"></span><br><span class="line">编辑hosts文件</span><br><span class="line">100和101全部为</span><br><span class="line">192.168.1.100  master.aming.com</span><br><span class="line">192.168.1.101   client.aming.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装ntpdate，并建立自动同步时间的任务计划：</span><br><span class="line">yum install -y ntp</span><br><span class="line">cront -e   //加入</span><br><span class="line">*/10  * * * * ntpdate time.windows.com</span><br></pre></td></tr></table></figure><h3 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装puppet 源</span><br><span class="line">rpm -ivh  http://yum.puppetlabs.com/el/6/p ... ease-6-7.noarch.rpm</span><br><span class="line"></span><br><span class="line">安装服务端程序</span><br><span class="line">yum install -y puppet-server</span><br><span class="line">启动服务</span><br><span class="line">service  puppetmaster start</span><br><span class="line"></span><br><span class="line">开机启动</span><br><span class="line">chkconfig  puppetmaster on</span><br></pre></td></tr></table></figure><h3 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">安装puppet 源</span><br><span class="line">rpm -ivh http://yum.puppetlabs.com/el/6/p ... ease-6-7.noarch.rpm</span><br><span class="line"></span><br><span class="line">安装客户端程序</span><br><span class="line">yum install -y puppet</span><br><span class="line"></span><br><span class="line">修改配置文件</span><br><span class="line">vi /etc/puppet/puppet.conf</span><br><span class="line">在最后面添加：</span><br><span class="line">listen = true</span><br><span class="line">server = master.aming.com</span><br><span class="line">runinterval = 30   //主动更新，每隔30s</span><br><span class="line"></span><br><span class="line">然后启动puppet服务</span><br><span class="line">/etc/init.d/puppet start</span><br><span class="line"></span><br><span class="line">手动生成ssl证书</span><br><span class="line">puppet agent  --test  --server  master.aming.com</span><br></pre></td></tr></table></figure><h3 id="服务端查看，签发客户端的证书"><a href="#服务端查看，签发客户端的证书" class="headerlink" title="服务端查看，签发客户端的证书"></a>服务端查看，签发客户端的证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puppet cert list --all</span><br><span class="line">会看到client.aming.com 的key，正常应该会在行首有一个+，如果没有说明还没有签发</span><br><span class="line"></span><br><span class="line">签发客户端</span><br><span class="line">puppet cert --sign client.aming.com</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">服务端上</span><br><span class="line">vi /etc/puppet/manifests/site.pp</span><br><span class="line">加入如下内容：</span><br><span class="line">node default &#123;</span><br><span class="line">file &#123;</span><br><span class="line">&quot;/tmp/123.txt&quot;: content =&gt; &quot;test,test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端上</span><br><span class="line">puppet agent --test --server  master.aming.com</span><br><span class="line">这样会在客户端上生成一个 /tmp/123.txt的文件，并且内容为 testtest</span><br></pre></td></tr></table></figure><h3 id="配置自动签发证书"><a href="#配置自动签发证书" class="headerlink" title="配置自动签发证书"></a>配置自动签发证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">服务端上删除客户端证书</span><br><span class="line">puppet cert clean client.aming.com</span><br><span class="line"></span><br><span class="line">客户端上删除ssl下的文件</span><br><span class="line">rm -rf /var/lib/puppet/ssl/*</span><br><span class="line"></span><br><span class="line">服务端更改配置文件</span><br><span class="line">vim /etc/puppet/puppet.conf在[main]下面加一行</span><br><span class="line">autosign = true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务端创建自动签发的配置文件</span><br><span class="line">vim /etc/puppet/autosign.conf</span><br><span class="line">加入如下内容：</span><br><span class="line">*.aming.com </span><br><span class="line"></span><br><span class="line">重启puppetmaster服务</span><br><span class="line">/etc/init.d/puppetmaster restart</span><br><span class="line"></span><br><span class="line">客户端重启puppet服务</span><br><span class="line">/etc/init.d/puppet restart</span><br><span class="line"></span><br><span class="line">这样就能在服务端上自动签发证书了。当然不重启服务，手动连一下服务端也可以</span><br><span class="line">客户端执行：</span><br><span class="line">puppet agent --test --server  master.aming.com</span><br><span class="line"></span><br><span class="line">扩展： puppet更新方式  http://www.cnphp6.com/archives/66975</span><br></pre></td></tr></table></figure><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">首先要理解几个概念，模块、类、资源。 模块是puppet的最大单元，模块里面有类，类下面有资源。 </span><br><span class="line">puppet管理的文件、用户、服务、任务计划等全部由这些单元组成。</span><br><span class="line"></span><br><span class="line">下面我们来定义一个模块：</span><br><span class="line">在服务端上做如下操作：</span><br><span class="line">mkdir /etc/puppet/modules/testm  //模块名字就是testm</span><br><span class="line">cd !$</span><br><span class="line">mkdir &#123;files,manifests,templates&#125;   //一个模块下需要有这三个目录，files存一些文件（可以为空），manifests存配置文件，templates存模板（可以留空）</span><br><span class="line">touch manifests/init.pp  //这个是必须的</span><br><span class="line">vi  manifests/init.pp   //内容如下</span><br><span class="line">class testm&#123;</span><br><span class="line">file &#123;&quot;/tmp/2.txt&quot;:</span><br><span class="line">owner =&gt; &quot;root&quot;,</span><br><span class="line">group =&gt; &quot;root&quot;,</span><br><span class="line">mode =&gt; 0400,</span><br><span class="line">source =&gt; &quot;puppet://$puppetserver/modules/testm/1.txt&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：类名字也叫做testm, 类下面定义了一个资源file，文件名字叫做/tmp/2.txt ，owner，group，mode定义文件的属主、数组以及权限，</span><br><span class="line">source定义这个文件从哪里获取。 $puppetserver一会也要定义一下，这里指的是puppet server服务器上/etc/puppet/modules/testm/files/1.txt</span><br><span class="line"></span><br><span class="line">下面要继续定义一个很关键的配置文件：</span><br><span class="line">vim  /etc/puppet/manifests/site.pp   //内容如下</span><br><span class="line">$puppetserver = &apos;master.aming.com&apos;</span><br><span class="line"></span><br><span class="line">node &apos;client.aming.com&apos;&#123;</span><br><span class="line">    include testm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：$puppetserver 定义服务端的主机名，node后面为客户端的主机名，这里面定义该客户端要加载的模块</span><br><span class="line">配置完成后，在客户端执行命令：</span><br><span class="line">puppet agent --test  --server=master.aming.com   //如果客户端上启动了puppet服务，不用执行这命令，它也会自动同步的</span><br><span class="line">上面的模块其实只是同步了一个文件而已，那么要想同步一个目录如何做？我们可以通过实现同步一个目录来做一个包发布系统。</span><br><span class="line">比如在一台机器上编译安装好了apache，那么就可以通过这样的模块把这个apache目录整个分发到其他机器上。</span><br><span class="line"></span><br><span class="line">模块配置文件如下：</span><br><span class="line">class apache&#123;</span><br><span class="line">file &#123;&quot;/usr/local/apache2&quot;:</span><br><span class="line">owner =&gt; &quot;root&quot;,</span><br><span class="line">group =&gt; &quot;root&quot;,</span><br><span class="line">source =&gt; &quot;puppet://$puppetserver/modules/apache/apache2&quot;,</span><br><span class="line">recurse =&gt; true,</span><br><span class="line">purge =&gt; true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">其中recurse=&gt;true 这个参数很关键，它表示递归的意思，没有这个不能同步目录。purge参数可以保证当服务端删除某个文件，客户端可以跟着删除。</span><br><span class="line"></span><br><span class="line">远程执行命令：</span><br><span class="line">exec &#123;&quot;123&quot;:</span><br><span class="line">unless =&gt; &quot;test -f /tmp/aminglinux.txt&quot;,</span><br><span class="line">path =&gt; [&quot;/bin&quot;, &quot;/sbin&quot;, &quot;/usr/bin&quot;, &quot;/usr/sbin&quot;],</span><br><span class="line">command =&gt; &quot;/bin/touch /tmp/aminglinux.txt&quot;</span><br><span class="line">&#125;</span><br><span class="line">说明：unless后面的命令作为一个条件，当条件成立时，不会执行下面的命令，如果想要条件成立时，执行下面的命令，用 onlyif。</span><br><span class="line">要注意的是，我们一定要给执行的这条命令加个条件，使用unless就可以，必须满足这个条件才能执行命令，否则这个命令会一直执行，不太妥当。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cron资源：</span><br><span class="line">cron &#123;&quot;aming1&quot;:</span><br><span class="line">command =&gt; &quot;/sbin/ntpdate time.windows.com&quot;,</span><br><span class="line">user =&gt; &quot;root&quot;,</span><br><span class="line">minute =&gt; &quot;*/10&quot;,</span><br><span class="line"># ensure =&gt; &quot;absent&quot;  //当增加了这行配置，则会把该cron删除掉</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：分时日月周分别对应puppet里面的minute，hour，monthday，month，weekday</span><br></pre></td></tr></table></figure><h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><ul><li><a href="http://blog.chinaunix.net/uid-20639775-id-3314583.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-20639775-id-3314583.html</a></li></ul><p>资源： </p><ul><li>package  <a href="http://puppet.wikidot.com/package" target="_blank" rel="noopener">http://puppet.wikidot.com/package</a></li><li>service <a href="http://puppet.wikidot.com/srv" target="_blank" rel="noopener">http://puppet.wikidot.com/srv</a></li><li>exec <a href="http://puppet.wikidot.com/exec" target="_blank" rel="noopener">http://puppet.wikidot.com/exec</a></li><li>cron <a href="http://puppet.wikidot.com/cron" target="_blank" rel="noopener">http://puppet.wikidot.com/cron</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;puppet的概念&quot;&gt;&lt;a href=&quot;#puppet的概念&quot; class=&quot;headerlink&quot; title=&quot;puppet的概念&quot;&gt;&lt;/a&gt;puppet的概念&lt;/h2&gt;&lt;p&gt;Puppet是一款使用GPLV2X协议授权的开源管理配置工具，用Ruby语言开发。其
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="http://blog.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="puppet" scheme="http://blog.zhangqifei.top/tags/puppet/"/>
    
  </entry>
  
  <entry>
    <title>运维自动化工具saltstack</title>
    <link href="http://blog.zhangqifei.top/2017/08/06/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7saltstack/"/>
    <id>http://blog.zhangqifei.top/2017/08/06/运维自动化工具saltstack/</id>
    <published>2017-08-06T10:42:22.000Z</published>
    <updated>2018-04-22T09:29:33.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Saltstack简介"><a href="#Saltstack简介" class="headerlink" title="Saltstack简介"></a>Saltstack简介</h2><p>SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，一般可以理解为简化版的puppet和加强版的func。SaltStack基于Python语言实现，结合轻量级消息队列（ZeroMQ）与Python第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack和PyYAML等）构建。通过部署SaltStack环境，我们可以在成千上万台服务器上做到批量执行命令，根据不同业务特性进行配置集中化管理、分发文件、采集服务器数据、操作系统基础及软件包管理等，SaltStack是运维人员提高工作效率、规范业务配置与操作的利器。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>简单</strong><ul><li>兼顾大规模部署与更小的系统的同时提供多功能性是很困难的，Salt是非常简单配置和维护，不管项目的大小。Salt可以胜任管理任意的数量的服务器，不管是本地网络，还是跨数据中心。架构采用C/S模式，在一个后台程序中集成必要功能。默认不需要复杂的配置就可以工作，同时可以定制用于特殊的需求。</li></ul></li><li><strong>并行执行</strong><ul><li>Salt的核心功能：</li><li>通过并行方式让远端节点执行命令</li><li>采用安全的加密/解析协议</li><li>最小化使用网络和负载</li><li>提供简单的程序接口</li><li>Salt引入了更细粒度的控制，允许不通过目标名字，二是通过系统属性分类</li></ul></li><li><strong>构建在成熟技术之上</strong><ul><li>Salt采用了很多技术和技巧。网络层采用优秀的ZeroMQ库，所以守护进程里面包含AMQ代理。Salt采用公钥和主控通讯，同时使用更快的AES加密通信，验证和加密都已经集成在Salt里面。Salt使用msgpack通讯，所以更快速和更轻量网络交换。</li></ul></li><li><strong>Python 客户端接口</strong><ul><li>为了实现简单的扩展，Salt执行例程可以写成简单的Python模块。客户端程序收集的数据可以发送回主控端，可以是其他任意程序。可以通过Python API调用Salt程序，或者命令行，因此，Salt可以用来执行一次性命令，或者大型应用程序中的一部分模块。</li></ul></li><li><strong>快速，灵活，可扩展</strong><ul><li>结果是一个系统可以高速在一台或者一组服务器执行命令。Salt速度很快，配置简单，扩展性好，提供了一个远程执行架构，可以管理多样化需求的任何数量的服务器。整合了世界上最好的远程执行方法，增强处理能力，扩展使用范围，使得可以适用任何多样化复杂的网络。</li></ul></li><li><strong>开源</strong><ul><li>Salt基于Apache 2.0 licence开发，可以用于开源或者自有项目。请反馈你的扩展给项目组，以便更多人受益，共同促进Salt发展。请在你的系统部署 系统，让运维更便捷。</li></ul></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>saltstack是基于C/S服务模式，在该架构中，服务器端叫做Master，客户端叫做Minion。传统的C/S模式我们这样理解，客户端发送请求给服务器端，服务器端接受到来自客户端的请求并处理完成后再返回客户端。 在saltstack架构中，不仅有传统的C/S服务模式，而且有消息队列中的发布与订阅（pub/sub）服务模式。目前我们一般用其C/S架构做批量管理。</p><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479473.png" alt="12"><br></center><ul><li>Master：控制中心,salt命令运行和资源状态管理</li><li>Minion : 需要管理的客户端机器,会主动去连接Mater端,并从Master端得到资源状态</li><li>信息,同步资源管理信息</li><li>States：配置管理的指令集</li><li>Modules：在命令行中和配置文件中使用的指令模块,可以在命令行中运行</li><li>Grains：minion端的变量,静态的</li><li>Pillar：minion端的变量,动态的比较私密的变量,可以通过配置文件实现同步minions定义</li><li>highstate：为minion端下发永久添加状态,从sls配置文件读取.即同步状态配置</li><li>salt_schedule：会自动保持客户端配置</li></ul><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>Master与Minion认证</p><ul><li>minion在第一次启动时，会在/etc/salt/pki/minion/（该路径在/etc/salt/minion里面设置）下自动生成minion.pem（private key）和 minion.pub（public key），然后将 minion.pub发送给master。</li><li>master在接收到minion的public key后，通过salt-key命令accept minion public key，这样在master的/etc/salt/pki/master/minions下的将会存放以minion id命名的 public key，然后master就能对minion发送指令了。<ul><li>SaltStack master启动后默认监听4505和4506两个端口。4505（publish_port）为saltstack的消息发布系统，4506（ret_port）为saltstack客户端与服务端通信的端口。如果使用lsof 查看4505端口，会发现所有的minion在4505端口持续保持在ESTABLISHED状态</li></ul></li></ul><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机名                IP地址               系统</span><br><span class="line">saltstack-server172.20.4.50CentOS release 6.9 (Final)</span><br><span class="line">saltstack-1        172.20.4.51CentOS release 6.9 (Final)</span><br><span class="line">saltstack-2        172.20.4.52CentOS release 6.9 (Final)</span><br></pre></td></tr></table></figure><h3 id="初始化环境："><a href="#初始化环境：" class="headerlink" title="初始化环境："></a>初始化环境：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install ntpdate -y &amp;&amp; ntpdate time1.aliyun.com                    #同步时间</span><br><span class="line">service iptables stop                                                 #关闭iptables</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/&quot;  /etc/selinux/config   #关闭selinux</span><br><span class="line">setenforce 0</span><br><span class="line"> </span><br><span class="line">cat &gt; saltstack.repo &lt;&lt;EOF</span><br><span class="line">[saltstack-repo]</span><br><span class="line">name=SaltStack repo for RHEL/CentOS $releasever</span><br><span class="line">baseurl=https://repo.saltstack.com/yum/RedHat/$releasever/$basearch/latest</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://repo.saltstack.com/yum/redhat/$releasever/$basearch/latest/SALTSTACK-GPG-KEY.pub</span><br><span class="line">EOF</span><br><span class="line">rpm --import https://repo.saltstack.com/yum/redhat/6/x86_64/latest/SALTSTACK-GPG-KEY.pub</span><br><span class="line">yum cleanall &amp;&amp; yum makecache                #更新yum源</span><br></pre></td></tr></table></figure><h3 id="master-端安装"><a href="#master-端安装" class="headerlink" title="master  端安装"></a>master  端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install salt-master</span><br><span class="line">mkdir /etc/salt/states</span><br><span class="line"> </span><br><span class="line">编辑/etc/salt/states</span><br><span class="line">interface: 0.0.0.0</span><br><span class="line">state_top: top.sls</span><br><span class="line">file_roots:</span><br><span class="line">   base:</span><br><span class="line">     - /etc/salt/states</span><br></pre></td></tr></table></figure><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479471.png" alt="12"><br></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动服务，并设置开机自启</span><br><span class="line">/etc/init.d/salt-master start</span><br><span class="line">chkconfig salt-master on</span><br></pre></td></tr></table></figure><h3 id="monitor端安装"><a href="#monitor端安装" class="headerlink" title="monitor端安装"></a>monitor端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置yum源和master方法一致</span><br><span class="line"></span><br><span class="line">yum -y install salt-minion</span><br><span class="line">修改/etc/salt/minion文件（slatstack-1/2 都更改成对应的id，master指向master的ip地址）</span><br></pre></td></tr></table></figure><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479476.png" alt=""><br></center><br>启动客户端，并设置开机自启动<br><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479474.png" alt=""><br></center><h3 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行salt-key -L  查看秘钥验证</span><br><span class="line">#执行Salt-key -a 加ID添加认证秘钥</span><br></pre></td></tr></table></figure><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479472.png" alt=""><br></center><h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479475.png" alt=""><br></center>    <h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><p>(1)、cp模块（实现远程文件、目录的复制，以及下载URL文件等操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将主服务器file_roots指定位置下的目录复制到被控主机</span><br><span class="line">salt &quot;*&quot; cp.get_dir salt://testdir /tmp/test</span><br><span class="line"></span><br><span class="line">将主服务器file_roots指定位置下的文件复制到被控主机</span><br><span class="line">salt &quot;*&quot; cp.get_file salt://testdir/testfile /tmp/testfile</span><br><span class="line"></span><br><span class="line">下载指定URL内容到被控主机指定位置</span><br><span class="line">salt &quot;*&quot; cp.get_url http://mirrors.163.com/.help/CentOS6-Base-163.repo /etc/yum.repos.d/CentOS6-Base-163.repo</span><br></pre></td></tr></table></figure></p><p>(2)、cmd模块（实现远程的命令行调用执行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt &quot;*&quot; cmd.run &apos;netstat -lntup&apos;</span><br></pre></td></tr></table></figure></p><p>(3)、cron模块（实现被控主机的crontab操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为指定的被控主机、root用户添加crontab信息</span><br><span class="line">salt &quot;*&quot; cron.set_job root &apos;*/5&apos; &apos;*&apos; &apos;*&apos; &apos;*&apos; &apos;*&apos; &apos;/usr/sbin/ntpdate time1.aliyun.com&apos;</span><br><span class="line"></span><br><span class="line">删除指定的被控主机、root用户的crontab信息</span><br><span class="line">salt &quot;*&quot; cron.rm_job root &apos;/usr/sbin/ntpdate time1.aliyun.com&apos;</span><br><span class="line"></span><br><span class="line">查看定时任务</span><br><span class="line">salt &apos;*&apos; cron.raw_cron root</span><br></pre></td></tr></table></figure></p><p>(4)、dnsutil模块（实现被控主机通用DNS操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为被控主机添加指定的hosts主机配置项</span><br><span class="line">salt &apos;*&apos; dnsutil.hosts_append /etc/hosts 127.0.0.1 test.saltstack.com</span><br></pre></td></tr></table></figure></p><p>(5)、file模块（被控主机文件常见操作，包括文件读写、权限、查找、校验等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; file.get_sum /etc/resolv.conf md5</span><br><span class="line">salt &apos;*&apos; file.stats /etc/resolv.conf</span><br></pre></td></tr></table></figure></p><p>(6)、network模块（返回被控主机网络信息）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; network.ip_addrs</span><br><span class="line">salt &apos;*&apos; network.interfaces</span><br></pre></td></tr></table></figure></p><p>(7)、pkg包管理模块（被控主机程序包管理，如yum、apt-get等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; pkg.install sysstat</span><br><span class="line">salt &apos;*&apos; pkg.file_list sysstat</span><br></pre></td></tr></table></figure></p><p>(8)、service 服务模块（被控主机程序包服务管理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; service.enable crond</span><br><span class="line">salt &apos;*&apos; service.disable crond</span><br><span class="line">salt &apos;*&apos; service.status crond</span><br><span class="line">salt &apos;*&apos; service.stop crond</span><br><span class="line">salt &apos;*&apos; service.start crond</span><br><span class="line">salt &apos;*&apos; service.restart crond</span><br><span class="line">salt &apos;*&apos; service.reload crond</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Saltstack简介&quot;&gt;&lt;a href=&quot;#Saltstack简介&quot; class=&quot;headerlink&quot; title=&quot;Saltstack简介&quot;&gt;&lt;/a&gt;Saltstack简介&lt;/h2&gt;&lt;p&gt;SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="http://blog.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="saltstack" scheme="http://blog.zhangqifei.top/tags/saltstack/"/>
    
  </entry>
  
  <entry>
    <title>8分钟带你深入浅出搞懂Nginx</title>
    <link href="http://blog.zhangqifei.top/2017/06/06/8%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%90%9E%E6%87%82Nginx/"/>
    <id>http://blog.zhangqifei.top/2017/06/06/8分钟带你深入浅出搞懂Nginx/</id>
    <published>2017-06-06T01:41:22.000Z</published>
    <updated>2018-04-22T09:29:33.065Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx/20180328172708395.png?raw=true" alt="架构图"><br><font color="gray">架构图</font><br></center><blockquote><p>上图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。</p></blockquote><hr><p><strong>反向代理服务器？</strong><br>经常听人说到一些术语，如反向代理，那么什么是反向代理，什么又是正向代理呢？</p><p><strong>正向代理：</strong></p><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx/20180328172708395.png?raw=true" alt="正向代理"><br><font color="gray">正向代理示意图</font><br></center><blockquote><p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</p></blockquote><p><strong>反向代理：</strong></p><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173053110.png?raw=true" alt="反向代理"><br><font color="gray">反向代理示意图</font><br></center><blockquote><p>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</p></blockquote><hr><center><br><font color="gray">Nginx的Master-Worker模式</font><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173552608.png?raw=true" alt="这里写图片描述"><br><font color="gray">nginx进程</font><br></center><blockquote><p>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p></blockquote><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173745376.png?raw=true" alt="Master-Worker模式"><br><font color="gray">Master-Worker模式</font><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173922132.png?raw=true" alt="这里写图片描述"><br></center><p><strong>nginx.conf</strong></p><ul><li><strong>Master进程的作用是？</strong><font color="gray">读取并验证配置文件nginx.conf；管理worker进程；</font></li><li><strong>Worker进程的作用是？</strong><font color="gray">每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</font></li></ul><hr><center><strong>思考：Nginx如何做到热部署？</strong></center><blockquote><p>所谓热部署，就是配置文件<code>nginx.conf</code>修改后，不需要<code>stop Nginx</code>，不需要中断请求，就能让配置文件生效！（<code>nginx -s reload</code> 重新加载 <code>nginx -t</code>检查配置 <code>nginx -s stop</code>停止）</p></blockquote><p>通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p><strong>方案一：</strong></p><font color="gray">修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道）</font><p><strong>方案二：</strong></p><font color="gray">修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</font><blockquote><p>Nginx采用的就是方案二来达到热部署的！</p></blockquote><hr><center><strong>思考：Nginx如何做到高并发下的高效处理？</strong><center><br><br><font color="gray">上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</font><br><br><font color="gray">作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞…</font><br><br><font color="gray">要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</font><br><br><font color="gray">Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</font><br><br><hr><br><center><strong>思考：Nginx挂了怎么办?</strong></center><br><font color="gray">Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</font><br><br><font color="gray">答案是：</font><strong>Keepalived+Nginx实现高可用。</strong><br><br><font color="gray">Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</font><br><br><strong>Keepalived+Nginx实现高可用的思路：</strong><br><br><font color="gray">第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</font><br><br><font color="gray">第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</font><br><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328175340149.png?raw=true" alt="这里写图片描述"><br><font color="gray">Keepalived+Nginx</font><br></center><hr><p><strong>我们的主战场：</strong><code>nginx.conf</code></p><ul><li>很多时候，在开发、测试环境下，我们都得自己去配置Nginx，就是去配置<code>nginx.conf</code>。</li><li><code>nginx.conf</code>是典型的分段配置文件，下面我们来分析下。</li></ul><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328175623369.png?raw=true" alt="这里写图片描述"><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//2018032817572351.png?raw=true" alt="这里写图片描述"><br></center><p><strong>其实这是把Nginx作为web server来处理静态资源。</strong></p><ul><li>第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</li><li>第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。</li><li>第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</li><li>第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。</li></ul><hr><p><strong>反向代理【proxy_pass】</strong></p><p>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理，上面已经说了，过程是透明的，比如说<code>request -&gt; Nginx -&gt; Tomcat</code>，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置<code>HTTP HEADER</code>。</p><hr><p><strong>负载均衡【upstream】</strong></p><p>上面的反向代理中，我们通过<code>proxy_pass</code>来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><ul><li>第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</li><li>第二，将proxy_pass替换成upstream指定的值即可。</li></ul><p><strong>负载均衡可能带来的问题？</strong></p><ul><li>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</li></ul><hr><p><strong>缓存</strong></p><p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。具体配置，大家可以参考Nginx官方文档，这里就不在展开了</p></center></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/zhangqifei/picture/blob/master
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="Nginx" scheme="http://blog.zhangqifei.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Systemd 入门教程：命令篇</title>
    <link href="http://blog.zhangqifei.top/2017/05/06/Systemd%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%91%BD%E4%BB%A4%E7%AF%87/"/>
    <id>http://blog.zhangqifei.top/2017/05/06/Systemd 入门教程：命令篇/</id>
    <published>2017-05-06T01:31:25.000Z</published>
    <updated>2018-04-22T09:30:14.835Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://zhangqifei.top/picture/ifeier/data/systemd.jpg" width="500" height="200" alt="markdown" align="center"></center><br>Systemd 是 Linux 系统工具，用来启动<strong>守护进程</strong>，已成为大多数发行版的标准配置。<br><br>本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，<strong>下一篇</strong>介绍如何用于实战。<br>历史上，Linux 的启动一直采用<code>init</code>进程。<br><br>下面的命令用来启动服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/apache2 start</span><br><span class="line"># 或者</span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure><br><br><strong>这种方法有两个缺点。</strong><br>1. 启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。<br>2. 启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。<br><br>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。<br><br>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。<br><br><br><center><img src="http://zhangqifei.top/picture/ifeier/data/dystemdname.jpg" width="500" height="200" alt="Systemdname" align="center"><br>（Systemd 作者 Lennart Poettering）</center><p>使用了 Systemd，就不需要再用<code>init</code>了。Systemd 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version    //查看 Systemd 的版本。</span><br></pre></td></tr></table></figure></p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的<strong>Unix 哲学</strong></p><p><center><img src="http://zhangqifei.top/picture/ifeier/data/systemd.png" width="500" height="200" alt="Systemdname" align="center"><br>（Systemd 架构图）</center><br>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST --&gt; Boot Sequence --&gt; Bootloader --&gt; kernel + initramfs(initrd) --&gt; rootfs--&gt; /sbin/init</span><br><span class="line">    init:CentOS 5: SysV init</span><br><span class="line">    CentOS 6: Upstart</span><br><span class="line">    CentOS 7: Systemd</span><br></pre></td></tr></table></figure><p>Systemd：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程</p><p><strong>Systemd新特性：</strong></p><ul><li>系统引导时实现服务并行启动</li><li>按需启动守护进程</li><li>自动化的服务依赖关系管理</li><li>同时采用socket式与D-Bus总线式激活服务</li><li>系统状态快照</li></ul><p><strong>核心概念：</strong> unit表示不同类型的systemd对象，通过配置文件进行标识和配置；文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息</p><p><strong>配置文件：</strong></p><ul><li>/usr/lib/systemd/system:每个服务最主要的启动脚本设置,类似于之前的/etc/init.d/</li><li>/run/systemd/system:系统执行过程中所产生的服务脚本,比上面目录优先运行</li><li>/etc/systemd/system:管理员建立的执行脚本,类似于/etc/rc.d/rcN.d/Sxx类的功能,比上面目录优先运行</li></ul><h3 id="Unit类型"><a href="#Unit类型" class="headerlink" title="Unit类型"></a>Unit类型</h3><ol><li>Systemctl –t help 查看unit类型</li><li>Service unit: 文件扩展名为.service, 用于定义系统服务</li><li>Target unit: 文件扩展名为.target，用于模拟实现运行级别</li><li>Device unit: .device, 用于定义内核识别的设备</li><li>Mount unit: .mount, 定义文件系统挂载点</li><li>Socket unit: .socket,用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动</li><li>Scope Unit：不是由 Systemd 启动的外部进程</li><li>Slice Unit：进程组</li><li>Snapshot unit: .snapshot, 管理系统快照</li><li>Swap unit: .swap, 用于标识swap设备</li><li>Automount unit: .automount，文件系统的自动挂载点</li><li>Path unit: .path，用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务，如：spool 目录</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>关键特性：</p><ul><li>基于socket的激活机制：socket与服务程序分离</li><li>基于d-bus的激活机制：</li><li>基于device的激活机制：</li><li>基于path的激活机制：</li><li>系统快照：保存各unit的当前状态信息于持久存储设备中向后兼容sysvinit脚本</li></ul><p>不兼容：</p><ul><li>systemctl命令固定不变，不可扩展</li><li>非由systemd启动的服务，systemctl无法与之通信和控制</li></ul><h3 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h3><ul><li>管理系统服务：CentOS 7: service unit</li></ul><blockquote><p>注意：能兼容早期的服务脚本<br> 命令：systemctl COMMAND name.service</p></blockquote><ul><li>启动：service name start ==&gt; systemctl start name.service</li><li>停止：service name stop ==&gt; systemctl stop name.service</li><li>重启：service name restart ==&gt; systemctl restart name.service</li><li>状态：service name status ==&gt; systemctl status name.service</li><li>条件式重启：已启动才重启，否则不做操作<br> service name condrestart ==&gt; systemctl try-restart name.service</li><li>重载或重启服务：先加载，再启动<br> systemctl reload-or-restart name.service</li><li>重载或条件式重启服务：<br> systemctl reload-or-try-restart name.service</li><li>禁止自动和手动启动：<br> systemctl mask name.service</li><li>取消禁止：<br> systemctl unmask name.service</li></ul><h3 id="服务查看"><a href="#服务查看" class="headerlink" title="服务查看"></a>服务查看</h3><ul><li>查看某服务当前激活与否的状态：<br>systemctl is-active name.service</li><li>查看所有已经激活的服务：<br>systemctl list-units –type|-t service </li><li>查看所有服务：<br>systemctl list-units –type service –all|-a</li></ul><p><strong>chkconfig命令的对应关系：</strong></p><ul><li>设定某服务开机自启：<br>chkconfig name on ==&gt; systemctl enable name.service</li><li>设定某服务开机禁止启动：<br>chkconfig name off ==&gt; systemctl disable name.service</li><li>查看所有服务的开机自启状态：<br>chkconfig –list ==&gt; systemctl list-unit-files –type service </li><li>用来列出该服务在哪些运行级别下启用和禁用<br>chkconfig sshd–list ==&gt;ls /etc/systemd/system/*.wants/sshd.service</li><li>查看服务是否开机自启：<br>systemctl is-enabled name.service</li><li>其它命令：查看服务的依赖关系：<br>systemctl list-dependencies name.service</li><li>杀掉进程：<br>systemctl kill unitname</li></ul><h3 id="服务状态"><a href="#服务状态" class="headerlink" title="服务状态"></a>服务状态</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --<span class="built_in">type</span> service --all显示状态</span><br><span class="line">    loaded:Unit:配置文件已处理</span><br><span class="line">    active(running):一次或多次持续处理的运行</span><br><span class="line">    active(exited):成功完成一次性的配置</span><br><span class="line">    active(waiting):运行中，等待一个事件</span><br><span class="line">    inactive:不运行</span><br><span class="line">    enabled:开机启动</span><br><span class="line">    disabled:开机不启动</span><br><span class="line">    static:开机不启动，但可被另一个启用的服务激活</span><br></pre></td></tr></table></figure><blockquote><p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。</p></blockquote><blockquote><p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p></blockquote><h3 id="systemctl-命令示例"><a href="#systemctl-命令示例" class="headerlink" title="systemctl 命令示例"></a>systemctl 命令示例</h3><ul><li>显示所有单元状态<br>systemctl或systemctl list-units</li><li>只显示服务单元的状态<br>systemctl –type=service ==&gt;systemctl -t=service</li><li>显示sshd服务单元<br>systemctl –l status sshd.service</li><li>验证sshd服务当前是否活动<br>systemctl is-active sshd</li><li>启动，停止和重启sshd服务<br>systemctl start sshd.service<br>systemctl stop sshd.service<br>systemctl restart sshd.service</li><li>重新加载配置<br>systemctl reload sshd.service</li><li>列出活动状态的所有服务单元<br>systemctl list-units –type=service</li><li>列出所有服务单元<br>systemctl list-units –type=service –all</li><li>查看服务单元的启用和禁用状态<br>systemctl list-unit-files  –type=service</li><li>列出失败的服务<br>systemctl –failed –type=servicesy</li><li>列出依赖的单元<br>systemctl list-dependencies sshd</li><li>验证sshd服务是否开机启动<br>systemctl is-enabled sshd</li><li>禁用network，使之不能自动启动,但手动可以<br>systemctl disable network</li><li>启用network<br>systemctl enable  network</li><li>禁用network，使之不能手动或自动启动<br>systemctl mask network</li><li>启用network<br>systemctl unmask network</li></ul><h3 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure><h3 id="hostnamectl查看当前主机的信息。"><a href="#hostnamectl查看当前主机的信息。" class="headerlink" title="hostnamectl查看当前主机的信息。"></a>hostnamectl查看当前主机的信息。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure><h3 id="localectl查看本地化设置。"><a href="#localectl查看本地化设置。" class="headerlink" title="localectl查看本地化设置。"></a>localectl查看本地化设置。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ localectl <span class="built_in">set</span>-locale LANG=en_GB.utf8</span><br><span class="line">$ localectl <span class="built_in">set</span>-keymap en_GB  </span><br><span class="line">```  </span><br><span class="line"><span class="comment">### timedatectl查看当前时区设置。</span></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-timezone America/New_York</span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time HH:MM:SS</span><br></pre></td></tr></table></figure><h3 id="loginctl查看当前登录的用户。"><a href="#loginctl查看当前登录的用户。" class="headerlink" title="loginctl查看当前登录的用户。"></a>loginctl查看当前登录的用户。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure><h3 id="service-unit文件格式"><a href="#service-unit文件格式" class="headerlink" title="service unit文件格式"></a>service unit文件格式</h3><ul><li>/etc/systemd/system：系统管理员和用户使用<br>/usr/lib/systemd/system：发行版打包者使用</li><li>以“#” 开头的行后面的内容会被认为是注释</li><li>相关布尔值，1、yes、on、true 都是开启，0、no、off、false 都是关闭</li><li>时间单位默认是秒，所以要用毫秒（ms）分钟（m）等须显式说明</li><li>service unit file文件通常由三部分组成：<br>[Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等<br>[Service]：与特定类型相关的专用选项；此处为Service类型<br>[Install]：定义由“systemctlenable”以及”systemctldisable“命令在实现服务启用或禁用时用到的一些选项</li></ul><h4 id="Unit-段的常用选项："><a href="#Unit-段的常用选项：" class="headerlink" title="[Unit]段的常用选项："></a>[Unit]段的常用选项：</h4><p> Description：描述信息<br> Documentation：文档地址<br> Requires：依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活<br> Wants：依赖到的其它units，弱依赖<br> Conflicts：定义units间的冲突关系<br> Condition…：当前 Unit 运行必须满足的条件，否则不会运行<br> Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败<br> After：定义unit的启动次序，表示当前unit应该晚于哪些unit启动，其功能与Before相反<br> BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行<br> Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</p><blockquote><p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。每个区块内部是一些等号连接的键值对;注意，键值对的等号两侧不能有空格.</p></blockquote><h4 id="Service-段的常用选项："><a href="#Service-段的常用选项：" class="headerlink" title="[Service]段的常用选项："></a>[Service]段的常用选项：</h4><p>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><ul><li>Type：定义影响ExecStart及相关参数的功能的unit进程启动类型<br>Type=simple：默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中<br>Type=forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止<br>Type=oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中<br>Type=dbus：与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行<br>Type=notify：在启动完成后会发送一个通知消息。还需要配合NotifyAccess 来让Systemd 接收消息<br>Type=idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务</li></ul><ul><li>EnvironmentFile：环境配置文件</li><li>ExecStart：指明启动unit要运行命令或脚本的绝对路径</li><li>ExecStartPre：ExecStart前运行(启动当前服务之前执行的命令)</li><li>ExecStartPost：ExecStart后运行(启动当前服务之后执行的命令)</li><li>ExecStop：指明停止unit要运行的命令或脚本(停止当前服务时执行的命令)</li><li>Restart：当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务(定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog)</li><li>ExecReload：重启当前服务时执行的命令</li><li>ExecStopPost：停止当其服务之后执行的命令</li><li>RestartSec：自动重启当前服务间隔的秒数</li><li>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</li><li>Environment：指定环境变量</li></ul><h4 id="Install-段的常用选项："><a href="#Install-段的常用选项：" class="headerlink" title="[Install]段的常用选项："></a>[Install]段的常用选项：</h4><p>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><ul><li>Alias：别名，可使用systemctlcommand Alias.service</li><li>RequiredBy：被哪些units所依赖，强依赖(它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中)</li><li>WantedBy：被哪些units所依赖，弱依赖(它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中)</li><li>Also：安装本服务的时候还要安装别的相关服务</li></ul><blockquote><p>注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载此配置文件,而后可以选择重启systemctl daemon-reload<br>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h3 id="服务Unit文件示例："><a href="#服务Unit文件示例：" class="headerlink" title="服务Unit文件示例："></a>服务Unit文件示例：</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/bak.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=backup  /etc</span><br><span class="line">Requires=atd.service</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/bash -c <span class="string">"echo /testdir/bak.sh|at now"</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>systemctl daemon-reload</li><li>systemctl start bak</li><li>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</li><li>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</li><li>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</li></ul><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> target units：</span><br><span class="line">     unit配置文件：.target</span><br><span class="line">     ls /usr/lib/systemd/system/*.target</span><br><span class="line">     systemctl list-unit-files --<span class="built_in">type</span> target  --all</span><br><span class="line"> 运行级别：</span><br><span class="line"> 0  ==&gt; runlevel0.target -&gt; poweroff.target</span><br><span class="line"> 1  ==&gt; runlevel1.target -&gt; rescue.target</span><br><span class="line"> 2  ==&gt; runlevel2.target -&gt; multi-user.target</span><br><span class="line"> 3  ==&gt; runlevel3.target -&gt; multi-user.target</span><br><span class="line"> 4  ==&gt; runlevel4.target -&gt; multi-user.target</span><br><span class="line"> 5  ==&gt; runlevel5.target -&gt; graphical.target</span><br><span class="line"> 6  ==&gt; runlevel6.target -&gt; reboot.target</span><br><span class="line"> </span><br><span class="line">（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</span><br><span class="line"> </span><br><span class="line">（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</span><br><span class="line"> </span><br><span class="line">（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</span><br><span class="line"> </span><br><span class="line"> 查看依赖性：</span><br><span class="line"> systemctl list-dependencies graphical.target</span><br><span class="line"> </span><br><span class="line"> 级别切换：</span><br><span class="line"> initN ==&gt; systemctl isolate name.target</span><br><span class="line"> systemctl isolate multi-user.target</span><br><span class="line"> 注：只有/lib/systemd/system/*.target文件中AllowIsolate=yes 才能切换(修改文件需执行systemctl daemon-reload才能生效)</span><br><span class="line"> </span><br><span class="line"> 查看target：</span><br><span class="line"> runlevel;   who -r</span><br><span class="line"> systemctl list-units --<span class="built_in">type</span> target</span><br><span class="line"> </span><br><span class="line"> 获取默认运行级别：</span><br><span class="line"> /etc/inittab==&gt; systemctl get-default</span><br><span class="line"> 修改默认级别：</span><br><span class="line"> /etc/inittab==&gt; systemctl <span class="built_in">set</span>-default name.target</span><br><span class="line"> systemctl <span class="built_in">set</span>-default multi-user.target</span><br><span class="line"> ls –l /etc/systemd/system/default.target</span><br><span class="line"> </span><br><span class="line"> 其它命令</span><br><span class="line"> 切换至紧急救援模式（单用户状态）：</span><br><span class="line"> systemctl rescue </span><br><span class="line"> 切换至emergency模式： </span><br><span class="line"> systemctl emergency</span><br><span class="line"> 其它常用命令：</span><br><span class="line"> 传统命令init，poweroff，halt，reboot都成为systemctl的软链接</span><br><span class="line"> 关机：systemctl halt、systemctl poweroff</span><br><span class="line"> 重启：systemctl reboot</span><br><span class="line"> 挂起：systemctl <span class="built_in">suspend</span></span><br><span class="line"> 休眠：systemctl hibernate</span><br><span class="line"> 休眠并挂起：systemctl hybrid-sleep</span><br></pre></td></tr></table></figure><p> Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code></p><h3 id="journalctl功能强大，用法非常多。"><a href="#journalctl功能强大，用法非常多。" class="headerlink" title="journalctl功能强大，用法非常多。"></a>journalctl功能强大，用法非常多。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ journalctl -b</span><br><span class="line">$ journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></span><br><span class="line">$ journalctl --since <span class="string">"20 min ago"</span></span><br><span class="line">$ journalctl --since yesterday</span><br><span class="line">$ journalctl --since <span class="string">"2015-01-10"</span> --until <span class="string">"2015-01-11 03:00"</span></span><br><span class="line">$ journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service</span><br><span class="line">$ journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ journalctl -b -u nginx.serviceqq</span><br><span class="line">-o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://zhangqifei.top/picture/ifeier/data/systemd.jpg&quot; width=&quot;500&quot; height=&quot;200&quot; alt=&quot;markdown&quot; align=&quot;center&quot;&gt;&lt;/center&gt;&lt;br
      
    
    </summary>
    
      <category term="centos" scheme="http://blog.zhangqifei.top/categories/centos/"/>
    
    
      <category term="centos7" scheme="http://blog.zhangqifei.top/tags/centos7/"/>
    
  </entry>
  
  <entry>
    <title>Linux各发行版时间线2017年版本</title>
    <link href="http://blog.zhangqifei.top/2017/03/05/Linux%E5%90%84%E5%8F%91%E8%A1%8C%E7%89%88%E6%97%B6%E9%97%B4%E7%BA%BF2017%E5%B9%B4%E7%89%88%E6%9C%AC/"/>
    <id>http://blog.zhangqifei.top/2017/03/05/Linux各发行版时间线2017年版本/</id>
    <published>2017-03-05T14:47:20.000Z</published>
    <updated>2018-04-22T09:30:14.906Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://zhangqifei.top/picture/ifeier/data/linux.jpg" width="500" height="200" alt="linux" align="center"></center><p>时间线目前版本16.12，于2017年2月1日发布，参见<a href="https://en.wikipedia.org/wiki/File:Linux_Distribution_Timeline.svg" target="_blank" rel="noopener">wikipedia</a></p><p>svg图片太长，无法显示，可以点击链接下载:<a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg" target="_blank" rel="noopener">点这儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://zhangqifei.top/picture/ifeier/data/linux.jpg&quot; width=&quot;500&quot; height=&quot;200&quot; alt=&quot;linux&quot; align=&quot;center&quot;&gt;&lt;/center&gt;


&lt;p&gt;时间
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://blog.zhangqifei.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux防火墙</title>
    <link href="http://blog.zhangqifei.top/2017/03/04/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://blog.zhangqifei.top/2017/03/04/Linux防火墙/</id>
    <published>2017-03-04T01:42:22.000Z</published>
    <updated>2018-04-22T09:29:33.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安全技术"><a href="#安全技术" class="headerlink" title="安全技术"></a>安全技术</h3><ul><li><strong>入侵检测与管理系统</strong>（Intrusion Detection Systems）：特点是不阻断任何网络访问，量化、定位来自内外网络的威胁情况，主要以提供报告和事后监督为主，提供有针对性的指导措施和安全决策依据。一般采用旁路部署方式</li><li><strong>入侵防御系统</strong>（Intrusion Prevention System）：以透明模式工作，分析数据包的内容如：溢出攻击、拒绝服务攻击、木马、蠕虫、系统漏洞等进行准确的分析判断，在判定为攻击行为后立即予以阻断，主动而有效的保护网络的安全，一般采用在线部署方式</li><li><strong>防火墙</strong>（FireWall ）：隔离功能，工作在网络或主机边缘，对进出网络或主机的数据包基于一定的规则检查，并在匹配某规则时由规则定义的行为进行处理的一组功能的组件，基本上的实现都是默认情况下关闭所有的通过型访问，只开放允许访问的策略</li></ul><h3 id="防火墙的分类"><a href="#防火墙的分类" class="headerlink" title="防火墙的分类"></a>防火墙的分类</h3><ul><li>主机防火墙：服务范围为当前主机</li><li>网络防火墙：服务范围为防火墙一侧的局域网</li><li>硬件防火墙：在专用硬件级别实现部分功能的防火墙；另一个部分功能基于软件实现，Checkpoint,NetScreen</li><li>软件防火墙：运行于通用硬件平台之上的防火墙的应用软件</li><li>网络层防火墙：OSI下面第三层</li><li>应用层防火墙/代理服务器：代理网关，OSI七层</li></ul><h4 id="网络型防火墙"><a href="#网络型防火墙" class="headerlink" title="网络型防火墙"></a>网络型防火墙</h4><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301140229118.png" alt="网络型防火墙"><br></center><ul><li>包过滤防火墙</li><li>网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL），通过检查数据流中每个数据的源地址，目的地址，所用端口号和协议状态等因素，或他们的组合来确定是否允许该数据包通过</li><li><strong>优点：</strong>对用户来说透明，处理速度快且易于维护</li><li><strong>缺点：</strong>无法检查应用层数据，如病毒等</li></ul><h4 id="应用层防火墙"><a href="#应用层防火墙" class="headerlink" title="应用层防火墙"></a>应用层防火墙</h4><p>应用层防火墙/代理服务型防火墙（Proxy Service）</p><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301140314791.png" alt="应用层防火墙"><br></center><ul><li>将所有跨越防火墙的网络通信链路分为两段</li><li>内外网用户的访问都是通过代理服务器上的“链接”来实现</li><li><strong>优点：</strong>在应用层对数据进行检查，比较安全</li><li><strong>缺点：</strong>增加防火墙的负载</li><li>现实生产环境中所使用的防火墙一般都是二者结合体</li><li>即先检查网络数据，通过之后再送到应用层去检查</li></ul><h3 id="iptables的基本认识"><a href="#iptables的基本认识" class="headerlink" title="iptables的基本认识"></a>iptables的基本认识</h3><p>Netfilter组件</p><ul><li>内核空间，集成在linux内核中</li><li>扩展各种网络服务的结构化底层框架</li><li>内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则</li><li>由信息过滤表（table）组成，包含控制IP包处理的规则集（rules），规则被分组放在链（chain）上</li></ul><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301144916228.png" alt="五个链"><br></center><p><strong>内核中数据包的传输过程</strong></p><ul><li>当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去</li><li>如果数据包就是进入本机的，数据包就会沿着图向下移动，到达INPUT链。数据包到达INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包经过OUTPUT链，然后到达POSTROUTING链输出</li><li>如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出</li></ul><h4 id="三种报文流向："><a href="#三种报文流向：" class="headerlink" title="三种报文流向："></a>三种报文流向：</h4><ul><li><strong>流入本机：</strong> PREROUTING –&gt; INPUT–&gt;用户空间进程</li><li><strong>流出本机：</strong> 用户空间进程–&gt;OUTPUT–&gt; POSTROUTING</li><li><strong>转发：</strong> PREROUTING –&gt; FORWARD –&gt; POSTROUTING</li></ul><h3 id="防火墙工具"><a href="#防火墙工具" class="headerlink" title="防火墙工具"></a>防火墙工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables</span><br><span class="line">    命令行工具，工作在用户空间</span><br><span class="line">    用来编写规则，写好的规则被送往netfilter，告诉内核如何去处理信息包</span><br><span class="line">firewalld</span><br><span class="line">    CentOS 7引入了新的前端管理工具</span><br><span class="line">    管理工具：</span><br><span class="line">        firewall-cmd命令行</span><br><span class="line">        firewall-config图形</span><br></pre></td></tr></table></figure><h3 id="iptables的组成"><a href="#iptables的组成" class="headerlink" title="iptables的组成"></a>iptables的组成</h3><p>iptables由<strong>四个表</strong>和<strong>五个链</strong>以及一些规则组成<br><strong>四个表table：</strong></p><ul><li><strong>filter表:</strong> 过滤规则表，根据预定义的规则过滤符合条件的数据包</li><li><strong>nat表:</strong> network address translation 地址转换规则表</li><li><strong>mangle:</strong> 修改数据标记位规则表</li><li><strong>Raw:</strong> 关闭NAT表上启用的连接跟踪机制，加快封包穿越防火墙速度</li></ul><p><strong>优先级由高到低:</strong> raw–&gt;mangle–&gt;nat–&gt;filter<br><strong>五个内置链chain</strong></p><ul><li>INPUT</li><li>OUTPUT</li><li>FORWARD</li><li>PREROUTING</li><li>POSTROUTING</li></ul><h4 id="Netfilter表和链对应关系"><a href="#Netfilter表和链对应关系" class="headerlink" title="Netfilter表和链对应关系"></a>Netfilter表和链对应关系</h4><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301140524380.png" alt="Netfilter表和链对应关系"><br>优先级由高到低: raw -&gt; mangle -&gt; nat -&gt; filter<br></center><h4 id="数据包过滤匹配流程"><a href="#数据包过滤匹配流程" class="headerlink" title="数据包过滤匹配流程"></a>数据包过滤匹配流程</h4><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301141001934.png" alt="数据包过滤匹配流程"><br></center><h3 id="iptables规则"><a href="#iptables规则" class="headerlink" title="iptables规则"></a>iptables规则</h3><p><strong>规则rule：</strong>根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作作出处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">匹配条件：默认为与条件，同时满足</span><br><span class="line">基本匹配：IP,端口,TCP的Flags（SYN,ACK等）</span><br><span class="line">扩展匹配：通过复杂高级功能匹配</span><br><span class="line">处理动作：称为target，跳转目标</span><br><span class="line">内建处理动作：ACCEPT(接收),DROP(婉转的拒绝),REJECT(强硬的拒绝),SNAT,DNAT,MASQUERADE,MARK,LOG...</span><br><span class="line">自定义处理动作：自定义chain，利用分类管理复杂情形</span><br></pre></td></tr></table></figure></p><blockquote><p>规则要添加在链上，才生效；添加在自定义上不会自动生效<br>链chain：<br>:   <strong>内置链：</strong>每个内置链对应于一个钩子函数<br>    <strong>自定义链：</strong>用于对内置链进行扩展或补充，可实现更灵活的规则组织管理机制；只有Hook钩子调用自定义链时，才生效</p></blockquote><p><strong>iptables规则添加时考量点</strong></p><ul><li>要实现哪种功能：判断添加在哪张表上</li><li>报文流经的路径：判断添加在哪个链上</li><li>报文的流向：判断源和目的</li><li>匹配规则：业务需要</li></ul><p><strong>链上规则的次序，即为检查的次序，因此隐含一定的法则</strong></p><ul><li>同类规则(访问同一应用)，匹配范围小的放上面</li><li>不同类规则(访问不同应用)，匹配到报文频率较大的放上面</li><li>将那些可由一条规则描述的多个规则合并为一个</li><li>设置默认策略</li></ul><p><strong>实验环境准备：</strong></p><ul><li><strong>Centos7:</strong> <ul><li><code>systemctl stop firewalld.service</code> </li><li><code>systemctl disable firewalld.service</code></li></ul></li><li><strong>Centos6:</strong> <ul><li><code>service iptables stop</code> </li><li><code>chkconfig iptables off</code></li></ul></li></ul><h3 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">man 8 iptables</span><br><span class="line"></span><br><span class="line">iptables [-t table] &#123;-A|-C|-D&#125; chain rule-specification</span><br><span class="line"></span><br><span class="line">iptables [-t table] -I chain [rulenum] rule-specification</span><br><span class="line"></span><br><span class="line">iptables [-t table] -R chain rulenum rule-specification</span><br><span class="line"></span><br><span class="line">iptables [-t table] -D chain rulenum</span><br><span class="line"></span><br><span class="line">iptables [-t table] -S [chain [rulenum]]</span><br><span class="line"></span><br><span class="line">iptables [-t table] &#123;-F|-L|-Z&#125; [chain [rulenum]] [options...]</span><br><span class="line"></span><br><span class="line">iptables [-t table] -N chain</span><br><span class="line"></span><br><span class="line">iptables [-t table] -X [chain]</span><br><span class="line"></span><br><span class="line">iptables [-t table] -P chain target</span><br><span class="line"></span><br><span class="line">iptables [-t table] -E old-chain-name new-chain-name</span><br><span class="line"></span><br><span class="line">rule-specification = [matches...] [target]</span><br><span class="line"></span><br><span class="line">match = -m matchname [per-match-options]</span><br><span class="line"></span><br><span class="line">target = -j targetname [per-target-options]</span><br></pre></td></tr></table></figure><p><strong>示例1：</strong><br>从172.18.99.1来的所有全部拒绝访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#iptables -A INPUT -s 172.18.99.1 -j DROP</span><br><span class="line">-A 添加 -I 插入 -s 后指定源地址 -j 策略</span><br></pre></td></tr></table></figure></p><h3 id="iptables命令规则格式："><a href="#iptables命令规则格式：" class="headerlink" title="iptables命令规则格式："></a>iptables命令规则格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t table] SUBCOMMAND chain [-m matchname[per-match-options]] -j targetname[per-target-options]</span><br><span class="line">--------------------------------</span><br><span class="line">-t table(表)：raw, mangle, nat, [filter]默认</span><br><span class="line">--------------------------------</span><br><span class="line">SUBCOMMAND(子命令)：</span><br><span class="line">1、链管理：</span><br><span class="line">-N：new, 自定义一条新的规则链</span><br><span class="line">-X：delete，删除自定义的空的规则链</span><br><span class="line">-P：Policy，设置默认策略；对filter表中的链而言，其默认策略有：</span><br><span class="line">ACCEPT：接受 </span><br><span class="line">DROP：丢弃 </span><br><span class="line">-E：重命名自定义链；引用计数不为0的自定义链不能够被重命名，也不能被删除</span><br><span class="line">2、查看：</span><br><span class="line">-L：list, 列出指定鏈上的所有规则，本选项须置后</span><br><span class="line">-n：numberic，以数字格式显示地址和端口号</span><br><span class="line">-v：verbose，详细信息 </span><br><span class="line">-vv更详细 </span><br><span class="line">-x：exactly，显示计数器结果的精确值,而非单位转换后的易读值(字节数更精确) </span><br><span class="line">--line-numbers：显示规则的序号 </span><br><span class="line">常用组合：</span><br><span class="line">--vnL </span><br><span class="line">--vvnxL --line-numbers </span><br><span class="line">-S selected,以iptables-save 命令格式显示链上规则</span><br><span class="line">3、规则管理：</span><br><span class="line">-A：append，追加 </span><br><span class="line">-I：insert, 插入，要指明插入至的规则编号，默认为第一条 </span><br><span class="line">-D：delete，删除(1) 指明规则序号(2) 指明规则本身 </span><br><span class="line">-R：replace，替换指定链上的指定规则编号 </span><br><span class="line">-F：flush，清空指定的规则链 </span><br><span class="line">-Z：zero，置零(包数指从头开始)</span><br><span class="line">iptables的每条规则都有两个计数器 </span><br><span class="line">(1) 匹配到的报文的个数 </span><br><span class="line">(2) 匹配到的所有报文的大小之和</span><br><span class="line">--------------------------------</span><br><span class="line">chain：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</span><br><span class="line">匹配条件</span><br><span class="line">基本：通用的，PARAMETERS</span><br><span class="line">扩展：需加载模块，MATCH EXTENTIONS</span><br><span class="line">1、基本匹配条件：无需加载模块，由iptables/netfilter自行提供</span><br><span class="line">[!] -s, --source  address[/mask][,...]：源IP地址或范围 </span><br><span class="line">[!] -d, --destination address[/mask][,...]：目标IP地址或范围 </span><br><span class="line">[!] -p, --protocol protocol：指定协议，可使用数字如0（all） </span><br><span class="line">protocol: tcp, udp, icmp, icmpv6,udplite,esp, ah, sctp, mhor  "all"  参看：/etc/protocols </span><br><span class="line">[!] -i, --in-interface name：报文流入的接口；只能应用于数据报文流入环节，只应用于INPUT、FORWARD、PREROUTING链 </span><br><span class="line">[!] -o, --out-interface name：报文流出的接口；只能应用于数据报文流出的环节，只应用于FORWARD、OUTPUT、POSTROUTING链</span><br><span class="line">2 扩展匹配条件：需要加载扩展模块（/usr/lib64/xtables/*.so），方可生效</span><br><span class="line">查看帮助man iptables-extensions</span><br><span class="line">(1)隐式扩展：在使用-p选项指明了特定的协议时，无需再用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块</span><br><span class="line">tcp协议的扩展选项</span><br><span class="line">[!] --source-port, --sport port[:port]：匹配报文源端口,可为端口范围 </span><br><span class="line">[!] --destination-port,--dportport[:port]：匹配报文目标端口,可为范围 </span><br><span class="line">[!] --tcp-flags mask comp</span><br><span class="line">mask 需检查的标志位列表，用,分隔 例如SYN,ACK,FIN,RST</span><br><span class="line">comp 在mask列表中必须为1的标志位列表，无指定则必须为0，用,分隔</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">--tcp-flags SYN,ACK,FIN,RST  SYN  表示要检查的标志位为SYN,ACK,FIN,RST四个，其中SYN必须为1，余下的必须为0 </span><br><span class="line">--tcp-flags SYN,ACK,FIN,RST SYN,ACK </span><br><span class="line">--tcp-flags ALL ALL </span><br><span class="line">--tcp_flagsALL NONE</span><br><span class="line">[!] --syn：用于匹配第一次握手</span><br><span class="line">相当于：--tcp-flags SYN,ACK,FIN,RST  SYN</span><br><span class="line"></span><br><span class="line">udp协议的扩展选项</span><br><span class="line">[!] --source-port, --sport port[:port]：匹配报文的源端口；可以是端口范围 </span><br><span class="line">[!] --destination-port,--dportport[:port]：匹配报文的目标端口；可以是端口范围</span><br><span class="line">icmp协议的扩展选项 </span><br><span class="line">[!] --icmp-type &#123;type[/code]|typename&#125;</span><br><span class="line">type/code </span><br><span class="line">0/0   echo-replyicmp应答 </span><br><span class="line">8/0   echo-request icmp请求</span><br><span class="line">(2)显式扩展：必须使用-m选项指明要调用的扩展模块的扩展机制，要手动加载扩展模块</span><br><span class="line">[-m matchname[per-match-options]]</span><br><span class="line">处理动作：</span><br><span class="line">-j targetname [per-target-options]</span><br><span class="line">简单：ACCEPT，DROP</span><br><span class="line">扩展：REJECT：--reject-with:icmp-port-unreachable默认 </span><br><span class="line">RETURN：返回调用链 </span><br><span class="line">REDIRECT：端口重定向 </span><br><span class="line">LOG：记录日志，dmesg </span><br><span class="line">MARK：做防火墙标记 </span><br><span class="line">DNAT：目标地址转换 </span><br><span class="line">SNAT：源地址转换 </span><br><span class="line">MASQUERADE：地址伪装</span><br><span class="line">... </span><br><span class="line">自定义链：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT 21144 packets, 3008K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">   21  1954 DROP       all  --  *      *       172.18.99.1          0.0.0.0/0           </span><br><span class="line">   16  1320 REJECT     all  --  *      *       172.18.99.1          0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line">pkts:包数</span><br><span class="line">bytes:字节数</span><br><span class="line">target:处理动作</span><br><span class="line">prot:协议</span><br><span class="line">opt:</span><br><span class="line">in:传入</span><br><span class="line">out:传出</span><br><span class="line">source:原地址 </span><br><span class="line">destination:目标地址</span><br></pre></td></tr></table></figure><p>······持续更新中······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安全技术&quot;&gt;&lt;a href=&quot;#安全技术&quot; class=&quot;headerlink&quot; title=&quot;安全技术&quot;&gt;&lt;/a&gt;安全技术&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入侵检测与管理系统&lt;/strong&gt;（Intrusion Detection Systems）：
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="防火墙" scheme="http://blog.zhangqifei.top/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7启动及排错</title>
    <link href="http://blog.zhangqifei.top/2017/01/07/CentOS7%E5%90%AF%E5%8A%A8%E5%8F%8A%E6%8E%92%E9%94%99/"/>
    <id>http://blog.zhangqifei.top/2017/01/07/CentOS7启动及排错/</id>
    <published>2017-01-06T17:50:32.000Z</published>
    <updated>2018-04-22T08:27:28.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS7引导顺序"><a href="#CentOS7引导顺序" class="headerlink" title="CentOS7引导顺序"></a>CentOS7引导顺序</h1><ul><li>UEFi或BIOS初始化，运行POST开机自检</li><li>选择启动设备</li><li>引导装载程序, centos7是grub2</li><li>加载装载程序的配置文件：<br>/etc/grub.d/<br>/etc/default/grub<br>/boot/grub2/grub.cfg</li><li>加载initramfs驱动模块加载内核选项</li><li>内核初始化，centos7使用systemd代替init </li><li>执行initrd.target所有单元，包括挂载/etc/fstab</li><li>从initramfs根文件系统切换到磁盘根目录</li><li>systemd执行默认target配置，配置文件/etc/systemd/system/default.target</li><li>systemd执行sysinit.target初始化系统及basic.target准备操作系统</li><li>systemd启动multi-user.target下的本机与服务器服务</li><li>systemd执行multi-user.target下的/etc/rc.d/rc.local</li><li>Systemd执行multi-user.target下的getty.target及登录服务</li><li>systemd执行graphical需要的服务</li></ul><h2 id="设置内核参数"><a href="#设置内核参数" class="headerlink" title="设置内核参数"></a>设置内核参数</h2><ul><li>设置内核参数，只影响当次启动</li><li>启动时，在linux16行后添加systemd.unit=desired.target</li><li>systemd.unit=emergency.target </li><li>systemd.unit=rescue.target</li><li>rescue.target 比emergency 支持更多的功能，例如日志等</li><li>systemctl  default  进入默认target</li></ul><h2 id="启动排错"><a href="#启动排错" class="headerlink" title="启动排错"></a>启动排错</h2><ul><li>文件系统损坏<br>先尝试自动修复，失败则进入emergency shell，提示用户修复</li><li>在/etc/fstab不存在对应的设备和UUID<br>等一段时间，如不可用，进入emergency shell</li><li>在/etc/fstab不存在对应挂载点<br>systemd尝试创建挂载点，否则提示进入emergency shell.</li><li>在/etc/fstab不正确的挂载选项<br>提示进入emergency shell</li></ul><h2 id="破解CentOS7的root口令方法一"><a href="#破解CentOS7的root口令方法一" class="headerlink" title="破解CentOS7的root口令方法一"></a>破解CentOS7的root口令方法一</h2><ul><li>启动时任意键暂停启动</li><li>按e键进入编辑模式</li><li>将光标移动linux16开始的行，添加内核参数rd.break</li><li>按ctrl-x启动</li><li>mount –o remount,rw  /sysroot</li><li>chroot /sysroot</li><li>passwd root</li><li>touch /.autorelabel</li><li>exit</li><li>reboot破解</li></ul><h2 id="破解CentOS7的root口令方法二"><a href="#破解CentOS7的root口令方法二" class="headerlink" title="破解CentOS7的root口令方法二"></a>破解CentOS7的root口令方法二</h2><ul><li>启动时任意键暂停启动</li><li>按e键进入编辑模式</li><li>将光标移动linux16开始的行，改为rw init=/sysroot/bin/sh</li><li>按ctrl-x启动</li><li>chroot /sysroot</li><li>passwd root</li><li>touch /.autorelabel</li><li>exit</li><li>reboot</li></ul><h2 id="centous7设置默认启动内核，并删除"><a href="#centous7设置默认启动内核，并删除" class="headerlink" title="centous7设置默认启动内核，并删除"></a>centous7设置默认启动内核，并删除</h2><p>配置文件 ：/boot/grub2/grub.cfg<br>修改：/etc/default/grub  GRUB_DEFAULT=saved saved改为0<br>grub2-mkconfig -o /boot/grub2/grub.crg 重新生成</p><p>删除没用的内核<br>/boot/ 和 /lib/modules/ 里面内核版本的东西 3.10.0.xxxx<br>grub2-mkconfig -o /boot/grub2/grub.crg 重新生成</p><h2 id="修复GRUB2"><a href="#修复GRUB2" class="headerlink" title="修复GRUB2"></a>修复GRUB2</h2><ul><li>GRUB”the Grand Unified Bootloader”引导提示时可以使用命令行界面可从文件系统引导</li><li>主要配置文件/boot/grub2/grub.cfg</li><li>修复配置文件grub2-mkconfig &gt; /boot/grub2/grub.cfg</li><li>修复grub grub2-install /dev/sdaBIOS环境grub2-install  UEFI环境</li><li>调整默认启动内核vim /etc/default/grubGRUB_DEFAULT=0</li></ul><center>![grub.cfg破坏][1]</center><h2 id="删除boot下所有"><a href="#删除boot下所有" class="headerlink" title="删除boot下所有"></a>删除boot下所有</h2><ol><li>进入救援模式</li><li>输入 1 continue</li><li>2 进入shell</li><li>chroot /mnt/sysimage  </li><li>mkdir /mnt/cdroom</li><li>mount -o /dev/cdroom /mnt/cdroom</li><li>rpm -ivh /mnt/cdroom/Packages/kernel-3.10.0.693.e17.x86.rpm –force </li><li>grub2-install /dev/sda</li><li>修复配置文件grub2-mkconfig &gt; /boot/grub2/grub.cfg</li><li>exit</li><li>reboot</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CentOS7引导顺序&quot;&gt;&lt;a href=&quot;#CentOS7引导顺序&quot; class=&quot;headerlink&quot; title=&quot;CentOS7引导顺序&quot;&gt;&lt;/a&gt;CentOS7引导顺序&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;UEFi或BIOS初始化，运行POST开机自检&lt;/li&gt;
      
    
    </summary>
    
      <category term="centos" scheme="http://blog.zhangqifei.top/categories/centos/"/>
    
    
      <category term="centos7" scheme="http://blog.zhangqifei.top/tags/centos7/"/>
    
  </entry>
  
  <entry>
    <title>自建CA认证和证书</title>
    <link href="http://blog.zhangqifei.top/2016/09/06/%E8%87%AA%E5%BB%BACA%E8%AE%A4%E8%AF%81%E5%92%8C%E8%AF%81%E4%B9%A6/"/>
    <id>http://blog.zhangqifei.top/2016/09/06/自建CA认证和证书/</id>
    <published>2016-09-05T16:07:24.000Z</published>
    <updated>2018-04-22T09:29:32.785Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://zhangqifei.top/picture/ifeier/data/openssl.jpg" width="500" height="200" alt="openssl" align="center"></center><p>一些概念：</p><p>PKI：Public Key Infrastructure</p><ul><li>签证机构：CA（Certificate Authority）</li><li>注册机构：RA（Register Authority）</li><li>证书吊销列表：CRL（Certificate Revoke Lists）</li><li>证书存取库</li></ul><p>X.509：定义了证书的结构和认证协议的标准。包括版本号、序列号、签名算法、颁发者、有效期限、主体名称、主体公钥、CRL分发点、扩展信息、发行者签名等</p><p>获取证书的两种方法：</p><ul><li>使用证书授权机构</li><li>生成签名请求（csr）</li><li>将csr发送给CA</li><li>从CA处接收签名</li><li>自签名的证书</li><li>自已签发自己的公钥重点介绍一下自建CA颁发机构和自签名。</li></ul><h2 id="自建CA颁发机构和自签名"><a href="#自建CA颁发机构和自签名" class="headerlink" title="自建CA颁发机构和自签名"></a>自建CA颁发机构和自签名</h2><p>实验用两台服务器，一台做ca颁发证书，一台去请求签名证书。</p><p>证书申请及签署步骤：</p><ol><li>生成申请请求</li><li>CA核验</li><li>CA签署</li><li>获取证书</li></ol><p>我们先看一下openssl的配置文件：<code>/etc/pki/tls/openssl.cnf</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####################################################################</span></span><br><span class="line">[ ca ]</span><br><span class="line">default_ca= CA_default<span class="comment"># The default ca section(默认的CA配置，是CA_default,下面第一个小节就是)</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line">[ CA_default ]</span><br><span class="line">dir= /etc/pki/CA<span class="comment"># Where everything is kept （dir变量）</span></span><br><span class="line">certs= <span class="variable">$dir</span>/certs<span class="comment"># Where the issued certs are kept（认证证书目录）</span></span><br><span class="line">crl_dir= <span class="variable">$dir</span>/crl<span class="comment"># Where the issued crl are kept（注销证书目录）</span></span><br><span class="line">database= <span class="variable">$dir</span>/index.txt<span class="comment"># database index file.（数据库索引文件）</span></span><br><span class="line">new_certs_dir= <span class="variable">$dir</span>/newcerts<span class="comment"># default place for new certs.（新证书的默认位置）</span></span><br><span class="line">certificate= <span class="variable">$dir</span>/cacert.pem <span class="comment"># The CA certificate（CA机构证书）</span></span><br><span class="line">serial= <span class="variable">$dir</span>/serial <span class="comment"># The current serial number（当前序号，默认为空，可以指定从01开始）</span></span><br><span class="line">crlnumber= <span class="variable">$dir</span>/crlnumber<span class="comment"># the current crl number（下一个吊销证书序号）</span></span><br><span class="line"><span class="comment"># must be commented out to leave a V1 CRL</span></span><br><span class="line">crl= <span class="variable">$dir</span>/crl.pem <span class="comment"># The current CRL（下一个吊销证书）</span></span><br><span class="line">private_key= <span class="variable">$dir</span>/private/cakey.pem<span class="comment"># The private key（CA机构的私钥）</span></span><br><span class="line">RANDFILE= <span class="variable">$dir</span>/private/.rand<span class="comment"># private random number file（随机数文件）</span></span><br><span class="line">x509_extensions= usr_cert<span class="comment"># The extentions to add to the cert</span></span><br><span class="line"><span class="comment"># Comment out the following two lines for the "traditional"</span></span><br><span class="line"><span class="comment"># (and highly broken) format.</span></span><br><span class="line">name_opt = ca_default<span class="comment"># Subject Name options（被颁发者，订阅者选项）</span></span><br><span class="line">cert_opt = ca_default<span class="comment"># Certificate field options（认证字段参数）</span></span><br><span class="line"><span class="comment"># Extension copying option: use with caution.</span></span><br><span class="line"><span class="comment"># copy_extensions = copy</span></span><br><span class="line"><span class="comment"># Extensions to add to a CRL. Note: Netscape communicator chokes on V2 CRLs</span></span><br><span class="line"><span class="comment"># so this is commented out by default to leave a V1 CRL.</span></span><br><span class="line"><span class="comment"># crlnumber must also be commented out to leave a V1 CRL.</span></span><br><span class="line"><span class="comment"># crl_extensions= crl_ext</span></span><br><span class="line">default_days= 365<span class="comment"># how long to certify for （默认的有效期天数是365）</span></span><br><span class="line">default_crl_days= 30<span class="comment"># how long before next CRL</span></span><br><span class="line">default_md= sha256<span class="comment"># use SHA-256 by default</span></span><br><span class="line">preserve= no<span class="comment"># keep passed DN ordering</span></span><br><span class="line"><span class="comment"># A few difference way of specifying how similar the request should look</span></span><br><span class="line"><span class="comment"># For type CA, the listed attributes must be the same, and the optional</span></span><br><span class="line"><span class="comment"># and supplied fields are just that :-)</span></span><br><span class="line">policy= policy_match  <span class="comment"># 是否匹配规则</span></span><br><span class="line"><span class="comment"># For the CA policy</span></span><br><span class="line">[ policy_match ]</span><br><span class="line">countryName= match   <span class="comment"># 国家名是否匹配，match为匹配</span></span><br><span class="line">stateOrProvinceName= match  <span class="comment"># 州或省名是否需要匹配</span></span><br><span class="line">organizationName= match  <span class="comment"># 组织名是否需要匹配</span></span><br><span class="line">organizationalUnitName= optional <span class="comment"># 组织的部门名字是否需要匹配</span></span><br><span class="line">commonName= supplied <span class="comment"># 注释</span></span><br><span class="line">emailAddress= optional <span class="comment"># 邮箱地址</span></span><br><span class="line"><span class="comment"># For the 'anything' policy</span></span><br><span class="line"><span class="comment"># At this point in time, you must list all acceptable 'object'</span></span><br><span class="line"><span class="comment"># types.</span></span><br><span class="line">[ policy_anything ]</span><br><span class="line">countryName= optional</span><br><span class="line">stateOrProvinceName= optional</span><br><span class="line">localityName= optional</span><br><span class="line">organizationName= optional</span><br><span class="line">organizationalUnitName= optional</span><br><span class="line">commonName= supplied</span><br><span class="line">emailAddress= optional</span><br><span class="line"><span class="comment">####################################################################</span></span><br></pre></td></tr></table></figure></p><p>重点关注下面的几个参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir             = /etc/pki/CA           <span class="comment"># Where everything is kept （dir变量）</span></span><br><span class="line">certs           = <span class="variable">$dir</span>/certs            <span class="comment"># Where the issued certs are kept（认证证书目录）</span></span><br><span class="line">database        = <span class="variable">$dir</span>/index.txt        <span class="comment"># database index file.（数据库索引文件）</span></span><br><span class="line">new_certs_dir   = <span class="variable">$dir</span>/newcerts         <span class="comment"># default place for new certs.（新证书的默认位置）</span></span><br><span class="line">certificate     = <span class="variable">$dir</span>/cacert.pem       <span class="comment"># The CA certificate（CA机构证书）</span></span><br><span class="line">serial          = <span class="variable">$dir</span>/serial           <span class="comment"># The current serial number（当前序号，默认为空，可以指定从01开始）</span></span><br><span class="line">private_key     = <span class="variable">$dir</span>/private/cakey.pem<span class="comment"># The private key（CA机构的私钥）</span></span><br></pre></td></tr></table></figure></p><h3 id="1、创建所需要的文件"><a href="#1、创建所需要的文件" class="headerlink" title="1、创建所需要的文件"></a>1、创建所需要的文件</h3><p><code>touch /etc/pki/CA/index.txt</code>生成证书索引数据库文件</p><p><code>echo 01 &gt; /etc/pki/CA/serial</code>指定第一个颁发证书的序列号,16进制数，比如可以从1a开始，一般从01开始。</p><h3 id="2、CA自签证书"><a href="#2、CA自签证书" class="headerlink" title="2、CA自签证书"></a>2、CA自签证书</h3><p>在作为CA的服务器上操作：</p><ul><li>生成私钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]<span class="comment">#(umask 066;openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096)</span></span><br><span class="line">Generating RSA private key, 4096 bit long modulus</span><br><span class="line">.....++</span><br><span class="line">..............................................++</span><br></pre></td></tr></table></figure><ul><li>生成自签名证书</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]<span class="comment">#openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 7300 -out /etc/pki/CA/cacert.pem</span></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">'.'</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN (国名（2个字母代码）[XX]：CN）</span><br><span class="line">State or Province Name (full name) []:Beijing （州或省名称（全称）北京）</span><br><span class="line">Locality Name (eg, city) [Default City]:Beijing （地区名称（如城市）[默认城市]：北京）</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:shangdigongsi （组织名称（如公司）：上帝公司）</span><br><span class="line">Organizational Unit Name (eg, section) []:opt （组织单位名称：opt）</span><br><span class="line">Common Name (eg, your name or your server<span class="string">'s hostname) []:centos （通用名称（例如，您的名字或您的服务器的主机名）[]：centos）</span></span><br><span class="line"><span class="string">Email Address []:1353250703@qq.com （电子邮件地址[]：1353250703@qq.com）</span></span><br></pre></td></tr></table></figure><blockquote><p>参数解析：</p><p>-new: 生成新证书签署请求<br>-x509: 专用于CA生成自签证书<br>-key: 生成请求时用到的私钥文件<br>-days n：证书的有效期限<br>-out /PATH/TO/SOMECERTFILE: 证书的保存路径</p></blockquote><h3 id="3、颁发证书"><a href="#3、颁发证书" class="headerlink" title="3、颁发证书"></a>3、颁发证书</h3><ul><li>在需要使用证书的主机生成证书请求(比如给一台作为博客web服务的服务器生成私钥)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]<span class="comment">#(umask 066; openssl genrsa -out /etc/pki/tls/private/blog.key 4096)</span></span><br><span class="line">Generating RSA private key, 4096 bit long modulus</span><br><span class="line">.....................................++</span><br><span class="line">......................................................................................................................++</span><br><span class="line">e is 65537 (0x10001)</span><br></pre></td></tr></table></figure><ul><li>生成证书申请文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]<span class="comment">#openssl req -new -key /etc/pki/tls/private/blog.key -days 3560 -out /etc/pki/tls/blog.csr</span></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">'.'</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN (国名（2个字母代码）[XX]：CN）</span><br><span class="line">State or Province Name (full name) []:Beijing（州或省名称（全称）北京）</span><br><span class="line">Locality Name (eg, city) [Default City]:Bejing （地区名称（如城市）[默认城市]：北京）</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:shangdigongsi（组织名称（如公司）：上帝公司）</span><br><span class="line">Organizational Unit Name (eg, section) []:centos（组织单位名称：opt）</span><br><span class="line">Common Name (eg, your name or your server<span class="string">'s hostname) []:opt （通用名称（例如，您的名字或您的服务器的主机名）[]：centos）</span></span><br><span class="line"><span class="string">Email Address []:（电子邮件地址[]：1353250703@qq.com）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Please enter the following '</span>extra<span class="string">' attributes （请输入以下“额外”属性）</span></span><br><span class="line"><span class="string">to be sent with your certificate request（要发送您的证书请求）</span></span><br><span class="line"><span class="string">A challenge password []:（密码[ ]：）</span></span><br><span class="line"><span class="string">An optional company name []:（可选的公司名称）</span></span><br></pre></td></tr></table></figure><ul><li>将证书请求文件传输给CA</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]<span class="comment">#scp /etc/pki/tls/blog.csr root@172.16.111.100:/tmp/</span></span><br><span class="line">root@172.16.111.100s password</span><br><span class="line">blog.csr                       100% 1773    1.7Mb/s</span><br></pre></td></tr></table></figure><ul><li>CA签署证书，并将证书颁发给请求者</li></ul><center><img src="http://zhangqifei.top/picture/ifeier/data/ca.jpg" width="500" height="200" alt="openssl" align="center"></center><blockquote><p>注意：默认国家，省，公司名称三项必须和CA一致</p></blockquote><ul><li>把blog.crt证书回传给申请者，申请者可以使用此证书。</li></ul><blockquote><p>证书可以放在网站里，比如tomacat服务有专门存放证书的地方，还有可能需要转化格式，此处使用方法暂略</p></blockquote><h3 id="4、吊销证书"><a href="#4、吊销证书" class="headerlink" title="4、吊销证书"></a>4、吊销证书</h3><ul><li>在客户端获取要吊销的证书的serial</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> /PATH/FROM/CERT_FILE -noout -serial -subject</span><br></pre></td></tr></table></figure><ul><li>在CA上，根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致，吊销证书：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem</span><br></pre></td></tr></table></figure><ul><li>指定第一个吊销证书的编号<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 01 &gt; /etc/pki/CA/crlnumber</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：这里只有在第一次更新证书吊销列表前，才需要执行指定编号。</p></blockquote><ul><li>更新证书吊销列表</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -gencrl -out /etc/pki/CA/crl/crl.pem</span><br></pre></td></tr></table></figure><ul><li>查看crl文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl crl -<span class="keyword">in</span> /etc/pki/CA/crl/crl.pem -noout -text</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.zybuluo.com/mrz1/note/1011025" target="_blank" rel="noopener">更加详细的步骤以及代码实现hexo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://zhangqifei.top/picture/ifeier/data/openssl.jpg&quot; width=&quot;500&quot; height=&quot;200&quot; alt=&quot;openssl&quot; align=&quot;center&quot;&gt;&lt;/center&gt;

&lt;p
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="CA" scheme="http://blog.zhangqifei.top/tags/CA/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-head</title>
    <link href="http://blog.zhangqifei.top/2016/07/06/linux%E5%91%BD%E4%BB%A4-head/"/>
    <id>http://blog.zhangqifei.top/2016/07/06/linux命令-head/</id>
    <published>2016-07-06T09:12:42.000Z</published>
    <updated>2018-04-22T09:29:33.121Z</updated>
    
    <content type="html"><![CDATA[<p>head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 </p><ol><li>命令格式：<br> head [参数]… [文件]…  </li><li>命令功能：<br> head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 </li><li>命令参数：<br> -q 隐藏文件名<br> -v 显示文件名<br> -c&lt;字节&gt; 显示字节数<br> -n&lt;行数&gt; 显示的行数</li></ol><p><strong>使用实例：</strong></p><h4 id="实例1：显示文件的前n行"><a href="#实例1：显示文件的前n行" class="headerlink" title="实例1：显示文件的前n行"></a>实例1：显示文件的前n行</h4><p>命令：<code>head -n n /etc/passwd</code></p><h4 id="实例2：显示文件前n个字节"><a href="#实例2：显示文件前n个字节" class="headerlink" title="实例2：显示文件前n个字节"></a>实例2：显示文件前n个字节</h4><p>命令：<code>head -c n /etc/passwd</code></p><h4 id="实例3：文件的除了最后n个字节以外的内容"><a href="#实例3：文件的除了最后n个字节以外的内容" class="headerlink" title="实例3：文件的除了最后n个字节以外的内容"></a>实例3：文件的除了最后n个字节以外的内容</h4><p>命令：<code>head -c -n /etc/passwd</code></p><h4 id="实例4：输出文件除了最后n行的全部内容"><a href="#实例4：输出文件除了最后n行的全部内容" class="headerlink" title="实例4：输出文件除了最后n行的全部内容"></a>实例4：输出文件除了最后n行的全部内容</h4><p>命令：<code>head -n -n /etc/passwd</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命令格式：&lt;br&gt; head [参数]… [文件]…  &lt;/li&gt;

      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-seq</title>
    <link href="http://blog.zhangqifei.top/2016/07/06/linux%E5%91%BD%E4%BB%A4-seq/"/>
    <id>http://blog.zhangqifei.top/2016/07/06/linux命令-seq/</id>
    <published>2016-07-06T08:12:42.000Z</published>
    <updated>2018-04-22T09:29:32.809Z</updated>
    
    <content type="html"><![CDATA[<p>seq命令用于产生从某个数到另外一个数之间的所有整数。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq [选项]... 尾数</span><br><span class="line">seq [选项]... 首数 尾数 </span><br><span class="line">seq [选项]... 首数 增量 尾数</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f, --format=格式 使用printf 样式的浮点格式</span><br><span class="line">-s, --separator=字符串 使用指定字符串分隔数字（默认使用：\n）</span><br><span class="line">-w, --equal-width 在列前添加0 使得宽度相同</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><strong>-f选项：指定格式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#seq -f &quot;%3g&quot; 9 11 </span><br><span class="line"> 9 </span><br><span class="line">10 </span><br><span class="line">11 </span><br><span class="line">注意：%后面指定数字的位数默认是%g，%3g那么数字位数不足部分是空格。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#seq -f &quot;str%03g&quot; 9 11 </span><br><span class="line">str009</span><br><span class="line">str010</span><br><span class="line">str011</span><br><span class="line">注意：这样的话数字位数不足部分是0，%前面制定字符串。</span><br></pre></td></tr></table></figure><p><strong>-w选项：指定输出数字同宽</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#seq -w 98 101</span><br><span class="line">098 </span><br><span class="line">099</span><br><span class="line">100 </span><br><span class="line">101 </span><br><span class="line">注意：不能和-f一起用，输出是同宽的。</span><br></pre></td></tr></table></figure></p><p><strong>s选项：指定分隔符（默认是回车）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#seq -s&quot;    &quot; -f&quot;str%03g&quot; 9 11     </span><br><span class="line">str009    str010    str011</span><br></pre></td></tr></table></figure></p><p><strong>指定\n作为分隔符号：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#seq -s&quot;`echo -e &quot;/t&quot;`&quot; 9 11</span><br><span class="line">9/t10/t11</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;seq命令用于产生从某个数到另外一个数之间的所有整数。&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-grep</title>
    <link href="http://blog.zhangqifei.top/2016/07/06/linux%E5%91%BD%E4%BB%A4-grep/"/>
    <id>http://blog.zhangqifei.top/2016/07/06/linux命令-grep/</id>
    <published>2016-07-06T07:12:42.000Z</published>
    <updated>2018-04-22T09:29:33.091Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是<code>Global Regular Expression Print</code>，表示全局正则表达式版本，它的使用权限是所有用户。</li><li>grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</li><li>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</li></ul><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><blockquote><p>grep [option] pattern file</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a   --text   #不要忽略二进制的数据。   </span><br><span class="line">-A&lt;显示行数&gt;   --after-context=&lt;显示行数&gt;   #除了显示符合范本样式的那一列之外，并显示该行之后的内容。   </span><br><span class="line">-b   --byte-offset   #在显示符合样式的那一行之前，标示出该行第一个字符的编号。   </span><br><span class="line">-B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前的内容。   </span><br><span class="line">-c    --count   #计算符合样式的列数。   </span><br><span class="line">-C&lt;显示行数&gt;    --context=&lt;显示行数&gt;或-&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前后的内容。   </span><br><span class="line">-d &lt;动作&gt;      --directories=&lt;动作&gt;   #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   </span><br><span class="line">-e&lt;范本样式&gt;  --regexp=&lt;范本样式&gt;   #指定字符串做为查找文件内容的样式。   </span><br><span class="line">-E      --extended-regexp   #将样式为延伸的普通表示法来使用。   </span><br><span class="line">-f&lt;规则文件&gt;  --file=&lt;规则文件&gt;   #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。   </span><br><span class="line">-F   --fixed-regexp   #将样式视为固定字符串的列表。   </span><br><span class="line">-G   --basic-regexp   #将样式视为普通的表示法来使用。   </span><br><span class="line">-h   --no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。   </span><br><span class="line">-H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。   </span><br><span class="line">-i    --ignore-case   #忽略字符大小写的差别。   </span><br><span class="line">-l    --file-with-matches   #列出文件内容符合指定的样式的文件名称。   </span><br><span class="line">-L   --files-without-match   #列出文件内容不符合指定的样式的文件名称。   </span><br><span class="line">-n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。   </span><br><span class="line">-q   --quiet或--silent   #不显示任何信息。   </span><br><span class="line">-r   --recursive   #此参数的效果和指定“-d recurse”参数相同。   </span><br><span class="line">-s   --no-messages   #不显示错误信息。   </span><br><span class="line">-v   --revert-match   #显示不包含匹配文本的所有行。   </span><br><span class="line">-V   --version   #显示版本信息。   </span><br><span class="line">-w   --word-regexp   #只显示全字符合的列。   </span><br><span class="line">-x    --line-regexp   #只显示全列符合的列。   </span><br><span class="line">-y   #此参数的效果和指定“-i”参数相同。</span><br></pre></td></tr></table></figure><h3 id="4．规则表达式："><a href="#4．规则表达式：" class="headerlink" title="4．规则表达式："></a>4．规则表达式：</h3><p>grep的规则表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">^  #锚定行的开始 如：&apos;^grep&apos;匹配所有以grep开头的行。    </span><br><span class="line">$  #锚定行的结束 如：&apos;grep$&apos;匹配所有以grep结尾的行。    </span><br><span class="line">.  #匹配一个非换行符的字符 如：&apos;gr.p&apos;匹配gr后接一个任意字符，然后是p。    </span><br><span class="line">*  #匹配零个或多个先前字符 如：&apos;*grep&apos;匹配所有一个或多个空格后紧跟grep的行。    </span><br><span class="line">.*   #一起用代表任意字符。   </span><br><span class="line">[]   #匹配一个指定范围内的字符，如&apos;[Gg]rep&apos;匹配Grep和grep。    </span><br><span class="line">[^]  #匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </span><br><span class="line">\(..\)  #标记匹配字符，如&apos;\(love\)&apos;，love被标记为1。    </span><br><span class="line">\&lt;      #锚定单词的开始，如:&apos;\&lt;grep&apos;匹配包含以grep开头的单词的行。    </span><br><span class="line">\&gt;      #锚定单词的结束，如&apos;grep\&gt;&apos;匹配包含以grep结尾的单词的行。    </span><br><span class="line">x\&#123;m\&#125;  #重复字符x，m次，如：&apos;0\&#123;5\&#125;&apos;匹配包含5个o的行。    </span><br><span class="line">x\&#123;m,\&#125;  #重复字符x,至少m次，如：&apos;o\&#123;5,\&#125;&apos;匹配至少有5个o的行。    </span><br><span class="line">x\&#123;m,n\&#125;  #重复字符x，至少m次，不多于n次，如：&apos;o\&#123;5,10\&#125;&apos;匹配5--10个o的行。   </span><br><span class="line">\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&apos;G\w*p&apos;匹配以G后跟零个或多个文字或数字字符，然后是p。   </span><br><span class="line">\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span><br><span class="line">\b    #单词锁定符，如: &apos;\bgrep\b&apos;只匹配grep。</span><br></pre></td></tr></table></figure></p><blockquote><p>POSIX字符:<br>为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[:alnum:]    #文字数字字符   </span><br><span class="line">[:alpha:]    #文字字符   </span><br><span class="line">[:digit:]    #数字字符   </span><br><span class="line">[:graph:]    #非空字符（非空格、控制字符）   </span><br><span class="line">[:lower:]    #小写字符   </span><br><span class="line">[:cntrl:]    #控制字符   </span><br><span class="line">[:print:]    #非空字符（包括空格）   </span><br><span class="line">[:punct:]    #标点符号   </span><br><span class="line">[:space:]    #所有空白字符（新行，空格，制表符）   </span><br><span class="line">[:upper:]    #大写字符   </span><br><span class="line">[:xdigit:]   #十六进制数字（0-9，a-f，A-F）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是&lt;code&gt;Global Regular Expression Print&lt;/code&gt;，表示全局正则表达式版本，它的使用权限是所有用户。&lt;/
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-echo</title>
    <link href="http://blog.zhangqifei.top/2016/07/06/linux%E5%91%BD%E4%BB%A4-echo/"/>
    <id>http://blog.zhangqifei.top/2016/07/06/linux命令-echo/</id>
    <published>2016-07-06T04:12:42.000Z</published>
    <updated>2018-04-22T09:29:32.654Z</updated>
    
    <content type="html"><![CDATA[<ol><li>echo命令向文件中写入内容，例如:使用echo指令覆盖文件内容，使用echo指令向文件追加内容，使用echo指令往文件中追加制表符。</li><li>echo向文件中输出内容的基本方法是使用IO重定向指令”&gt;”，默认情况下echo输出到标准输出中，使用”&gt;”指令可重定向输出到文件中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">用法：echo [短选项]... [字符串]...  </span><br><span class="line">  或：echo 长选项  </span><br><span class="line">将 string 回显到标准输出。  </span><br><span class="line">  -n 不尾随换行符  </span><br><span class="line">  -e 启用解释反斜杠的转义功能  </span><br><span class="line">  -E 禁用解释反斜杠的转义功能(默认)  </span><br><span class="line">      --help 显示此帮助信息并退出  </span><br><span class="line">      --version 显示版本信息并退出  </span><br><span class="line">若-e 可用，则以下序列即可识别：  </span><br><span class="line">  \\    反斜杠  </span><br><span class="line">  \a    响铃声  </span><br><span class="line">  \b    会删除字符间的所有空格  *</span><br><span class="line">  \c    不再产生新的输出  </span><br><span class="line">  \e    转义符    </span><br><span class="line">  \f    换页  </span><br><span class="line">  \n    新行 * </span><br><span class="line">  \r    回车  </span><br><span class="line">  \t    水平制表符  </span><br><span class="line">  \v    竖直制表符  </span><br><span class="line">  \0NNN   字节数以八进制数 NNN (1至3位)表示  </span><br><span class="line">  \xHH    字节数以十六进制数 HH (1至2位)表示</span><br></pre></td></tr></table></figure><h3 id="使用’-b’选项"><a href="#使用’-b’选项" class="headerlink" title="使用’\b’选项"></a>使用’\b’选项</h3><blockquote><p>‘-e’后带上’\b’会删除字符间的所有空格。<br>注意： Linux中的选项’-e’扮演了转义字符反斜线的翻译器。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;Tecmint \bis \ba \bcommunity \bof \bLinux \bNerds&quot; </span><br><span class="line">TecmintisacommunityofLinuxNerds</span><br></pre></td></tr></table></figure><h3 id="使用’-n’选项"><a href="#使用’-n’选项" class="headerlink" title="使用’\n’选项"></a>使用’\n’选项</h3><blockquote><p>“-e”后面的带上’\n’行会在遇到的地方作为新的一行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;Tecmint \nis \na \ncommunity \nof \nLinux \nNerds&quot; </span><br><span class="line">Tecmint </span><br><span class="line">is </span><br><span class="line">a </span><br><span class="line">community </span><br><span class="line">of </span><br><span class="line">Linux </span><br><span class="line">Nerds</span><br></pre></td></tr></table></figure><h3 id="使用’-t’选项"><a href="#使用’-t’选项" class="headerlink" title="使用’\t’选项"></a>使用’\t’选项</h3><blockquote><p>‘-e’后面跟上’\t’会在空格间加上水平制表符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;Tecmint \tis \ta \tcommunity \tof \tLinux \tNerds&quot; </span><br><span class="line">Tecmint     is  a   community   of  Linux   Nerds</span><br></pre></td></tr></table></figure><h4 id="也可以同时使用换行‘-n‘与水平制表符‘-t‘"><a href="#也可以同时使用换行‘-n‘与水平制表符‘-t‘" class="headerlink" title="也可以同时使用换行‘\n‘与水平制表符‘\t‘"></a>也可以同时使用换行‘\n‘与水平制表符‘\t‘</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;\n\tTecmint \n\tis \n\ta \n\tcommunity \n\tof \n\tLinux \n\tNerds&quot; </span><br><span class="line"> </span><br><span class="line">    Tecmint </span><br><span class="line">    is </span><br><span class="line">    a </span><br><span class="line">    community </span><br><span class="line">    of </span><br><span class="line">    Linux </span><br><span class="line">    Nerds</span><br></pre></td></tr></table></figure><h3 id="使用’-v’选项"><a href="#使用’-v’选项" class="headerlink" title="使用’\v’选项"></a>使用’\v’选项</h3><blockquote><p>‘-e’后面跟上’\v’会加上垂直制表符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;\vTecmint \vis \va \vcommunity \vof \vLinux \vNerds&quot; </span><br><span class="line"> </span><br><span class="line">Tecmint </span><br><span class="line">        is </span><br><span class="line">           a </span><br><span class="line">             community </span><br><span class="line">                       of </span><br><span class="line">                          Linux </span><br><span class="line">                                Nerds</span><br></pre></td></tr></table></figure><h4 id="也可以同时使用换行’-n’与垂直制表符’-v’"><a href="#也可以同时使用换行’-n’与垂直制表符’-v’" class="headerlink" title="也可以同时使用换行’\n’与垂直制表符’\v’"></a>也可以同时使用换行’\n’与垂直制表符’\v’</h4><blockquote><p>注意： 你可以按照你的需求连续使用两个或者多个垂直制表符，水平制表符与换行符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;\n\vTecmint \n\vis \n\va \n\vcommunity \n\vof \n\vLinux \n\vNerds&quot; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Tecmint </span><br><span class="line"> </span><br><span class="line">is </span><br><span class="line"> </span><br><span class="line">a </span><br><span class="line"> </span><br><span class="line">community </span><br><span class="line"> </span><br><span class="line">of </span><br><span class="line"> </span><br><span class="line">Linux </span><br><span class="line"> </span><br><span class="line">Nerds</span><br></pre></td></tr></table></figure><h3 id="使用’-r’选项"><a href="#使用’-r’选项" class="headerlink" title="使用’\r’选项"></a>使用’\r’选项</h3><blockquote><p>‘-e’后面跟上‘\r’来指定输出中的回车符。（LCTT 译注：会覆写行开头的字符）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;Tecmint \ris a community of Linux Nerds&quot; </span><br><span class="line"> </span><br><span class="line">is a community of Linux Nerds</span><br></pre></td></tr></table></figure><h3 id="使用’-c’选项"><a href="#使用’-c’选项" class="headerlink" title="使用’\c’选项"></a>使用’\c’选项</h3><blockquote><p>‘-e’后面跟上’\c’会抑制输出后面的字符并且最后不会换新行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;Tecmint is a community \cof Linux Nerds&quot; </span><br><span class="line">Tecmint is a community [root@centos7 ~]#</span><br></pre></td></tr></table></figure><h3 id="‘-n’会在echo完后不会输出新行"><a href="#‘-n’会在echo完后不会输出新行" class="headerlink" title="‘-n’会在echo完后不会输出新行"></a>‘-n’会在echo完后不会输出新行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -n &quot;Tecmint is a community of Linux Nerds&quot; </span><br><span class="line">Tecmint is a community of Linux Nerds[root@centos7 ~]#</span><br></pre></td></tr></table></figure><h3 id="使用’-a’选项"><a href="#使用’-a’选项" class="headerlink" title="使用’\a’选项"></a>使用’\a’选项</h3><blockquote><p>‘-e’后面跟上’\a’选项会听到声音警告。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# echo -e &quot;Tecmint is a community of \aLinux Nerds&quot; </span><br><span class="line">Tecmint is a community of Linux Nerds</span><br></pre></td></tr></table></figure><blockquote><p>注意： 在你开始前，请先检查你的音量设置。</p></blockquote><h3 id="使用echo命令打印所有的文件和文件夹（ls命令的替代）"><a href="#使用echo命令打印所有的文件和文件夹（ls命令的替代）" class="headerlink" title="使用echo命令打印所有的文件和文件夹（ls命令的替代）"></a>使用echo命令打印所有的文件和文件夹（ls命令的替代）</h3><blockquote><p>比如，让我们假设你想要打印所有的’.sh’文件，使用下面的命令。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 app]#echo *.sh</span><br><span class="line">backup73.sh f1.sh hello.sh scp73.sh systeminfo.sh</span><br><span class="line">[root@centos7 ~]# echo *  //打印所有与ls相当</span><br><span class="line">backup73.sh etc f1.sh hello.sh scp73.sh systeminfo.sh wang</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;echo命令向文件中写入内容，例如:使用echo指令覆盖文件内容，使用echo指令向文件追加内容，使用echo指令往文件中追加制表符。&lt;/li&gt;
&lt;li&gt;echo向文件中输出内容的基本方法是使用IO重定向指令”&amp;gt;”，默认情况下echo输出到标准输出中，使用
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-cat</title>
    <link href="http://blog.zhangqifei.top/2016/07/06/linux%E5%91%BD%E4%BB%A4-cat/"/>
    <id>http://blog.zhangqifei.top/2016/07/06/linux命令-cat/</id>
    <published>2016-07-06T01:32:42.000Z</published>
    <updated>2018-04-22T09:29:32.718Z</updated>
    
    <content type="html"><![CDATA[<p>cat命令的用途是连接文件或标准输入并打印。这个命令<strong>常用来显示文件内容</strong>，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。<br>语法格式</p><blockquote><p>cat [-AbeEnstTuv] [–help] [–version] fileName</p></blockquote><p>参数说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-n 或 --number：由 1 开始对所有输出的行数编号。</span><br><span class="line">-b 或 --number-nonblank：和 -n :     相似，只不过对于空白行不编号。</span><br><span class="line">-s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。</span><br><span class="line">-v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</span><br><span class="line">-E 或 --show-ends : 在每行结束处显示 $。</span><br><span class="line">-T 或 --show-tabs: 将 TAB 字符显示为 ^I。</span><br><span class="line">-e : 等价于 -vE。</span><br><span class="line">-A, --show-all：等价于 -vET。</span><br><span class="line">-e：等价于&quot;-vE&quot;选项；</span><br><span class="line">-t：等价于&quot;-vT&quot;选项；</span><br></pre></td></tr></table></figure></p><h3 id="实例1：把-textfile1-的文档内容加上行号后输入-textfile2-这个文档里："><a href="#实例1：把-textfile1-的文档内容加上行号后输入-textfile2-这个文档里：" class="headerlink" title="实例1：把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里："></a>实例1：把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</h3><p><code>cat -n textfile1 &gt; textfile2</code></p><h3 id="实例2：把-textfile1-和-textfile2-的文档内容加上行号（空白行不加）之后将内容附加到-textfile3-文档里："><a href="#实例2：把-textfile1-和-textfile2-的文档内容加上行号（空白行不加）之后将内容附加到-textfile3-文档里：" class="headerlink" title="实例2：把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里："></a>实例2：把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</h3><p><code>cat -b textfile1 textfile2 &gt;&gt; textfile3</code></p><h3 id="实例3：清空-etc-test-txt-文档内容："><a href="#实例3：清空-etc-test-txt-文档内容：" class="headerlink" title="实例3：清空 /etc/test.txt 文档内容："></a>实例3：清空 /etc/test.txt 文档内容：</h3><p><code>cat /dev/null &gt; /etc/test.txt</code></p><h3 id="实例4：cat-也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入："><a href="#实例4：cat-也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：" class="headerlink" title="实例4：cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入："></a>实例4：cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：</h3><p><code>cat /dev/fd0 &gt; OUTFILE</code></p><h3 id="实例5：相反的，如果想把-image-file-写到软盘，输入："><a href="#实例5：相反的，如果想把-image-file-写到软盘，输入：" class="headerlink" title="实例5：相反的，如果想把 image file 写到软盘，输入："></a>实例5：相反的，如果想把 image file 写到软盘，输入：</h3><p><code>cat IMG_FILE &gt; /dev/fd0</code></p><h3 id="tac-反向列示"><a href="#tac-反向列示" class="headerlink" title="tac (反向列示)"></a>tac (反向列示)</h3><p>命令：<br><code>tac log.txt</code><br>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat log.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">[root@localhost ~]# tac log.txt </span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><blockquote><p>说明：<br>tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cat命令的用途是连接文件或标准输入并打印。这个命令&lt;strong&gt;常用来显示文件内容&lt;/strong&gt;，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。&lt;br&gt;语法格式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cat [-AbeEnst
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-bc</title>
    <link href="http://blog.zhangqifei.top/2016/07/06/linux%E5%91%BD%E4%BB%A4-bc/"/>
    <id>http://blog.zhangqifei.top/2016/07/06/linux命令-bc/</id>
    <published>2016-07-06T01:12:42.000Z</published>
    <updated>2018-04-22T09:29:33.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>bc (选项) (参数)</p></blockquote><h3 id="选项值"><a href="#选项值" class="headerlink" title="选项值"></a>选项值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-i：强制进入交互式模式；</span><br><span class="line">-l：定义使用的标准数学库</span><br><span class="line">； -w：对POSIX bc的扩展给出警告信息；</span><br><span class="line">-q：不打印正常的GNU bc环境信息；</span><br><span class="line">-v：显示指令版本信息；</span><br><span class="line">-h：显示指令的帮助信息。</span><br></pre></td></tr></table></figure><h3 id="实例1："><a href="#实例1：" class="headerlink" title="实例1："></a>实例1：</h3><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#bc</span><br><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type `warranty&apos;. </span><br><span class="line">15*2</span><br><span class="line">30       //输入 quit 退出。</span><br></pre></td></tr></table></figure></p><h3 id="实例2：通过管道符"><a href="#实例2：通过管道符" class="headerlink" title="实例2：通过管道符:"></a>实例2：通过管道符:</h3><p>命令：<code>[root@centos7 ~]#echo &quot;15+5&quot; | bc  //20</code></p><h3 id="实例3：scale-2-设小数位，2-代表保留两位"><a href="#实例3：scale-2-设小数位，2-代表保留两位" class="headerlink" title="实例3：scale=2 设小数位，2 代表保留两位:"></a>实例3：scale=2 设小数位，2 代表保留两位:</h3><p>命令：<code>[root@centos7 ~]#echo &#39;scale=2;(2.777-1.44444)/1&#39; |bc  //1.33</code></p><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>bc 除了 scale 来设定小数位之外，还有 ibase 和 obase 来其它进制的运算:</p><h4 id="把十进制11000000-转换为二进制192"><a href="#把十进制11000000-转换为二进制192" class="headerlink" title="把十进制11000000;转换为二进制192"></a>把十进制11000000;转换为二进制192</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#abc=11000000 </span><br><span class="line">[root@centos7 ~]#echo &quot;obase=10;ibase=2;$abc&quot; | bc  //192</span><br></pre></td></tr></table></figure></p><h4 id="把十进制11000000-转换为二进制192-1"><a href="#把十进制11000000-转换为二进制192-1" class="headerlink" title="把十进制11000000;转换为二进制192"></a>把十进制11000000;转换为二进制192</h4><p>命令：<code>[root@centos7 ~]#echo &quot;obase=2;192&quot; |bc  //11000000</code></p><h3 id="实例4、计算平方和平方根："><a href="#实例4、计算平方和平方根：" class="headerlink" title="实例4、计算平方和平方根："></a>实例4、计算平方和平方根：</h3><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#echo &quot;10^10&quot; | bc  //10000000000</span><br><span class="line">[root@centos7 ~]#echo &quot;sqrt(100)&quot; | bc  //10</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;bc (选项) (参数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;选项值&quot;&gt;&lt;a href=&quot;#选项值
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-test</title>
    <link href="http://blog.zhangqifei.top/2016/07/06/linux%E5%91%BD%E4%BB%A4-test/"/>
    <id>http://blog.zhangqifei.top/2016/07/06/linux命令-test/</id>
    <published>2016-07-06T00:42:42.000Z</published>
    <updated>2018-04-22T09:29:32.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>test命令是shell环境中测试条件表达式的实用工具。 </p></blockquote><p>语法：</p><blockquote><p>test(选项) 选项 </p></blockquote><p>选项 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-b&lt;文件&gt;：如果文件为一个块特殊文件，则为真；</span><br><span class="line">-c&lt;文件&gt;：如果文件为一个字符特殊文件，则为真；</span><br><span class="line">-d&lt;文件&gt;：如果文件为一个目录，则为真；</span><br><span class="line">-e&lt;文件&gt;：如果文件存在，则为真；</span><br><span class="line">-f&lt;文件&gt;：如果文件为一个普通文件，则为真；</span><br><span class="line">-g&lt;文件&gt;：如果设置了文件的SGID位，则为真；</span><br><span class="line">-G&lt;文件&gt;：如果文件存在且归该组所有，则为真；</span><br><span class="line">-k&lt;文件&gt;：如果设置了文件的粘着位，则为真；</span><br><span class="line">-O&lt;文件&gt;：如果文件存在并且归该用户所有，则为真；</span><br><span class="line">-p&lt;文件&gt;：如果文件为一个命名管道，则为真；</span><br><span class="line">-r&lt;文件&gt;：如果文件可读，则为真；</span><br><span class="line">-s&lt;文件&gt;：如果文件的长度不为零，则为真；</span><br><span class="line">-S&lt;文件&gt;：如果文件为一个套接字特殊文件，则为真；</span><br><span class="line">-u&lt;文件&gt;：如果设置了文件的SUID位，则为真；</span><br><span class="line">-w&lt;文件&gt;：如果文件可写，则为真；</span><br><span class="line">-x&lt;文件&gt;：如果文件可执行，则为真。</span><br></pre></td></tr></table></figure></p><blockquote><p>实例:linux中shell编程中的test常见用法： </p></blockquote><h3 id="判断表达式"><a href="#判断表达式" class="headerlink" title="判断表达式"></a>判断表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if test #表达式为真</span><br><span class="line">if test ! #表达式为假 </span><br><span class="line">test 表达式1 –a 表达式2 #两个表达式都为真 </span><br><span class="line">test 表达式1 –o 表达式2 #两个表达式有一个为真 </span><br><span class="line">test 表达式1 ! 表达式2 #条件求反</span><br></pre></td></tr></table></figure><h3 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test –n 字符串 #字符串的长度非零 </span><br><span class="line">test –z 字符串 #字符串的长度是否为零 </span><br><span class="line">test 字符串1＝字符串2 #字符串是否相等，若相等返回true </span><br><span class="line">test 字符串1!＝字符串2 #字符串是否不等，若不等反悔false</span><br></pre></td></tr></table></figure><h3 id="判断整数"><a href="#判断整数" class="headerlink" title="判断整数"></a>判断整数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test 整数1 -eq 整数2 #整数相等 </span><br><span class="line">test 整数1 -ge 整数2 #整数1大于等于整数2 </span><br><span class="line">test 整数1 -gt 整数2 #整数1大于整数2 </span><br><span class="line">test 整数1 -le 整数2 #整数1小于等于整数2 </span><br><span class="line">test 整数1 -lt 整数2 #整数1小于整数2 </span><br><span class="line">test 整数1 -ne 整数2 #整数1不等于整数2</span><br></pre></td></tr></table></figure><h3 id="判断文件"><a href="#判断文件" class="headerlink" title="判断文件"></a>判断文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test File1 –ef File2 两个文件是否为同一个文件，可用于硬连接。主要判断两个文件是否指向同一个inode。 </span><br><span class="line">test File1 –nt File2 判断文件1是否比文件2新 </span><br><span class="line">test File1 –ot File2 判断文件1比是否文件2旧 </span><br><span class="line">test –b file #文件是否块设备文件 </span><br><span class="line">test –c File #文件并且是字符设备文件 </span><br><span class="line">test –d File #文件并且是目录 </span><br><span class="line">test –e File #文件是否存在 （常用） </span><br><span class="line">test –f File #文件是否为正规文件 （常用） </span><br><span class="line">test –g File #文件是否是设置了组id </span><br><span class="line">test –G File #文件属于的有效组ID </span><br><span class="line">test –h File #文件是否是一个符号链接（同-L） </span><br><span class="line">test –k File#文件是否设置了Sticky bit位 </span><br><span class="line">test –b File #文件存在并且是块设备文件 </span><br><span class="line">test –L File #文件是否是一个符号链接（同-h） </span><br><span class="line">test –o File #文件的属于有效用户ID </span><br><span class="line">test –p File #文件是一个命名管道 </span><br><span class="line">test –r File #文件是否可读 </span><br><span class="line">test –s File #文件是否是非空白文件 </span><br><span class="line">test –t FD #文件描述符是在一个终端打开的 </span><br><span class="line">test –u File #文件存在并且设置了它的set-user-id位 </span><br><span class="line">test –w File #文件是否存在并可写 </span><br><span class="line">test –x File #文件属否存在并可执行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;test命令是shell环境中测试条件表达式的实用工具。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;test(选项) 选项 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项 :&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>ab命令压力测试</title>
    <link href="http://blog.zhangqifei.top/2016/06/06/ab%E5%91%BD%E4%BB%A4%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>http://blog.zhangqifei.top/2016/06/06/ab命令压力测试/</id>
    <published>2016-06-06T01:41:22.000Z</published>
    <updated>2018-04-22T09:29:32.756Z</updated>
    
    <content type="html"><![CDATA[<p>网站性能压力测试是服务器网站性能调优过程中必不可缺少的一环。只有让服务器处在高压情况下，才能真正体现出软件、硬件等各种设置不当所暴露出的问题。</p><p>性能测试工具目前最常见的有以下几种：ab、http_load、webbench、siege。今天我们专门来介绍ab。</p><p>ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。</p><p><a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="noopener">官方参数文档</a></p><h4 id="一、ab的原理"><a href="#一、ab的原理" class="headerlink" title="一、ab的原理"></a>一、ab的原理</h4><p>ab是apachebench命令的缩写。</p><p>ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。</p><p>ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机。</p><h4 id="二、ab的安装"><a href="#二、ab的安装" class="headerlink" title="二、ab的安装"></a>二、ab的安装</h4><p>ab的安装非常简单，如果是源码安装apache的话，那就更简单了。apache安装完毕后ab命令存放在apache安装目录的bin目录下。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/apache2/bin</span><br></pre></td></tr></table></figure></p><p>如果apache 是通过yum的RPM包方式安装的话，ab命令默认存放在/usr/bin目录下。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which ab</span><br></pre></td></tr></table></figure></p><p>注意：如果不想安装apache但是又想使用ab命令的话，我们可以直接安装apache的工具包httpd-tools。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install httpd-tools</span><br></pre></td></tr></table></figure></p><p>查看ab是否安装成功，可以切换到上述目录下，使用ab –V命令进行检测。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -V</span><br></pre></td></tr></table></figure></p><p>如果ab安装成功，通过ab –V命令则会显示ab的相迎版本，如上图示。</p><p>注意以上是在linux平台下进行安装的，如果是windows平台下，我们也可以下载对应的apache版本进行安装。</p><p>目前apache最新版2.4.10，apache官网已经没有windows下载的版本。</p><h4 id="三、ab参数说明"><a href="#三、ab参数说明" class="headerlink" title="三、ab参数说明"></a>三、ab参数说明</h4><p>有关ab命令的使用，我们可以通过帮助命令进行查看。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab --help</span><br></pre></td></tr></table></figure></p><p>下面我们对这些参数，进行相关说明。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">-n  在测试会话中所执行的请求个数。默认时，仅执行一个请求。</span><br><span class="line"></span><br><span class="line">-c  一次产生的请求个数。默认是一次一个。</span><br><span class="line"></span><br><span class="line">-t  测试所进行的最大秒数。其内部隐含值是-n 50000，它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。</span><br><span class="line"></span><br><span class="line">-p  包含了需要POST的数据的文件。</span><br><span class="line"></span><br><span class="line">-P  对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。</span><br><span class="line"></span><br><span class="line">-T  POST数据所使用的Content-type头信息。</span><br><span class="line"></span><br><span class="line">-v  设置显示信息的详细程度-4或更大值会显示头信息，3或更大值可以显示响应代码(404,200等),2或更大值可以显示警告和其他信息。</span><br><span class="line"></span><br><span class="line">-V  显示版本号并退出。</span><br><span class="line"></span><br><span class="line">-w  以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。</span><br><span class="line"></span><br><span class="line">-i  执行HEAD请求，而不是GET。</span><br><span class="line"></span><br><span class="line">-x  设置&lt;table&gt;属性的字符串。</span><br><span class="line"></span><br><span class="line">-X  对请求使用代理服务器。</span><br><span class="line"></span><br><span class="line">-y  设置&lt;tr&gt;属性的字符串。</span><br><span class="line"></span><br><span class="line">-z  设置&lt;td&gt;属性的字符串。</span><br><span class="line"></span><br><span class="line">-C  对请求附加一个Cookie:行。其典型形式是name=value的一个参数对，此参数可以重复。</span><br><span class="line"></span><br><span class="line">-H  对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含了以冒号分隔的字段和值的对(如,&quot;Accept-Encoding:zip/zop;8bit&quot;)。</span><br><span class="line"></span><br><span class="line">-A  对服务器提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即,是否发送了401认证需求代码)，此字符串都会被发送。</span><br><span class="line"></span><br><span class="line">-h  显示使用方法。</span><br><span class="line"></span><br><span class="line">-d  不显示&quot;percentage served within XX [ms] table&quot;的消息(为以前的版本提供支持)。</span><br><span class="line"></span><br><span class="line">-e  产生一个以逗号分隔的(CSV)文件，其中包含了处理每个相应百分比的请求所需要(从1%到100%)的相应百分比的(以微妙为单位)时间。由于这种格式已经“二进制化”，所以比&apos;gnuplot&apos;格式更有用。</span><br><span class="line"></span><br><span class="line">-g  把所有测试结果写入一个&apos;gnuplot&apos;或者TSV(以Tab分隔的)文件。此文件可以方便地导入到Gnuplot,IDL,Mathematica,Igor甚至Excel中。其中的第一行为标题。</span><br><span class="line"></span><br><span class="line">-i  执行HEAD请求，而不是GET。</span><br><span class="line"></span><br><span class="line">-k  启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。默认时，不启用KeepAlive功能。</span><br><span class="line"></span><br><span class="line">-q  如果处理的请求数大于150，ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。此-q标记可以抑制这些信息。</span><br></pre></td></tr></table></figure></p><h4 id="四、ab性能指标"><a href="#四、ab性能指标" class="headerlink" title="四、ab性能指标"></a>四、ab性能指标</h4><p>在进行性能测试过程中有几个指标比较重要：</p><p>1、吞吐率（Requests per second）</p><p>服务器并发处理能力的量化描述，单位是reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。</p><p>记住：吞吐率是基于并发用户数的。这句话代表了两个含义：</p><ul><li>a、吞吐率和并发用户数相关</li><li>b、不同的并发用户数下，吞吐率一般是不同的</li></ul><p>计算公式：总请求数/处理完成这些请求数所花费的时间，即<code>Request per second=Complete requests/Time taken for tests</code>必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。</p><p>2、并发连接数（The number of concurrent connections）</p><p>并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。</p><p>3、并发用户数（Concurrency Level）</p><p>要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在HTTP/1.1下，IE7支持两个并发连接，IE8支持6个并发连接，FireFox3支持4个并发连接，所以相应的，我们的并发用户数就得除以这个基数。</p><p>4、用户平均请求等待时间（Time per request）</p><p>计算公式：处理完成所有请求数所花费的时间/（总请求数/并发用户数），即：<code>Time per request=Time taken for tests/（Complete requests/Concurrency Level）</code></p><p>5、服务器平均请求等待时间（Time per request:across all concurrent requests）</p><p>计算公式：处理完成所有请求数所花费的时间/总请求数，即：<code>Time taken for/testsComplete requests</code>可以看到，它是吞吐率的倒数。</p><p>同时，它也等于用户平均请求等待时间/并发用户数，即<code>Time per request/Concurrency Level</code></p><h4 id="五、ab实际使用"><a href="#五、ab实际使用" class="headerlink" title="五、ab实际使用"></a>五、ab实际使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#ab -c 10 -n 100 http://a.ilanni.com/index.php</span><br><span class="line">-c    10表示并发用户数为10</span><br><span class="line">-n    100表示请求总数为100</span><br><span class="line">http://a.ilanni.com/index.php表示请求的目标URL</span><br><span class="line">这行表示同时处理100个请求并运行10次index.php文件。</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]#ab -c 10 -n 100 http://a.ilanni.com/index.php</span><br><span class="line">Benchmarking 47.93.96.25 (be patient).....done</span><br><span class="line"></span><br><span class="line">Server Software:        Apache/2.4.29  ##apache版本 </span><br><span class="line">Server Hostname:        ip地址   ##请求的机子 </span><br><span class="line">Server Port:            80  ##请求端口</span><br><span class="line"></span><br><span class="line">Document Path:          index.php</span><br><span class="line">Document Length:        18483 bytes  ##页面长度</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10  ##并发数</span><br><span class="line">Time taken for tests:   25.343 seconds  ##共使用了多少时间</span><br><span class="line">Complete requests:      100  ##请求数</span><br><span class="line">Failed requests:        11  ##失败请求</span><br><span class="line">   (Connect: 0, Receive: 0, Length: 11, Exceptions: 0)</span><br><span class="line">Total transferred:      1873511 bytes  ##总共传输字节数，包含http的头信息等</span><br><span class="line">HTML transferred:       1848311 bytes  ##html字节数，实际的页面传递字节数</span><br><span class="line">Requests per second:    3.95 [#/sec] (mean)  ##每秒多少请求，这个是非常重要的参数数值，服务器的吞吐量</span><br><span class="line">Time per request:       2534.265 [ms] (mean)  ##用户平均请求等待时间</span><br><span class="line">Time per request:       253.426 [ms] (mean, across all concurrent requests)  ##服务器平均处理时间，</span><br><span class="line">Transfer rate:          72.19 [Kbytes/sec] received  ##每秒获取的数据长度</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    8   3.9     10      13</span><br><span class="line">Processing:  1222 2453 322.6   2520    3436</span><br><span class="line">Waiting:     1175 2385 320.4   2452    3372</span><br><span class="line">Total:       1222 2461 322.5   2528    3444</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%   2528  ## 50%的请求在25ms内返回 </span><br><span class="line">  66%   2534  ## 60%的请求在26ms内返回 </span><br><span class="line">  75%   2538</span><br><span class="line">  80%   2539</span><br><span class="line">  90%   2545</span><br><span class="line">  95%   2556</span><br><span class="line">  98%   3395</span><br><span class="line">  99%   3444</span><br><span class="line"> 100%   3444 (longest request)</span><br></pre></td></tr></table></figure><blockquote><p>apache的ab工具也算是一种ddos攻击工具<br>nginx吞吐率就是要比apache高。<br>根据前面我们提到的性能指标Requests per second吞吐率越高，服务器性能越好。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网站性能压力测试是服务器网站性能调优过程中必不可缺少的一环。只有让服务器处在高压情况下，才能真正体现出软件、硬件等各种设置不当所暴露出的问题。&lt;/p&gt;
&lt;p&gt;性能测试工具目前最常见的有以下几种：ab、http_load、webbench、siege。今天我们专门来介绍ab。
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="命令" scheme="http://blog.zhangqifei.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>CentOS（6、7）修改主机名(hostname)</title>
    <link href="http://blog.zhangqifei.top/2016/06/06/CentOS%EF%BC%886%E3%80%817%EF%BC%89%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D(hostname)/"/>
    <id>http://blog.zhangqifei.top/2016/06/06/CentOS（6、7）修改主机名(hostname)/</id>
    <published>2016-06-06T01:41:22.000Z</published>
    <updated>2018-04-22T09:29:33.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="centos6"><a href="#centos6" class="headerlink" title="centos6"></a>centos6</h2><p>需要修改两处：一处是<code>/etc/sysconfig/network</code>，另一处是<code>/etc/hosts</code>，只修改任一处会导致系统启动异常。首先切换到root用户。</p><ul><li><code>/etc/sysconfig/network</code><br>打开该文件，里面有一行 `HOSTNAME=localhost.localdomain，修改 localhost.localdomain 为你的主机名。</li><li><code>/etc/hosts</code><br>打开该文件，会有一行 <code>127.0.0.1 localhost.localdomain localhost</code>其中 127.0.0.1 是本地环路地址， localhost.localdomain 是主机名(hostname)，也就是你待修改的。</li></ul><p>将上面两个文件修改完后，并不能立刻生效。如果要立刻生效的话，可以用 <code>hostname your-hostname</code> 作临时修改(或者修改完之后执行<code>exec bash</code>立即改变)，它只是临时地修改主机名，查看主机名<code>uname -n</code>系统重启后会恢复原样的。</p><p>但修改上面两个文件是永久的，重启系统会得到新的主机名。<br>最后，重启后查看主机名 uname -n 。</p><h2 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h2><p>临时生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# hostname 132</span><br><span class="line">[root@centos7 ~]# hostname</span><br><span class="line">132</span><br></pre></td></tr></table></figure></p><p>永久生效（不会立刻修改，需重启）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# hostnamectl set-hostname centos7</span><br><span class="line">(或者修改完之后执行`exec bash`立即改变)，</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;centos6&quot;&gt;&lt;a href=&quot;#centos6&quot; class=&quot;headerlink&quot; title=&quot;centos6&quot;&gt;&lt;/a&gt;centos6&lt;/h2&gt;&lt;p&gt;需要修改两处：一处是&lt;code&gt;/etc/sysconfig/network&lt;/code&gt;，另一处是
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.zhangqifei.top/categories/linux/"/>
    
    
      <category term="CentOS" scheme="http://blog.zhangqifei.top/tags/CentOS/"/>
    
  </entry>
  
</feed>
